§ "Cortex" is a family of processors developed by ARM, a semiconductor company based in Cambridge (UK). ARM defines x3 architecture profiles for the Cortex family:
1. A-profile (applications, 32/64-bit) -> targets high performance markets (such as PC, mobile phones and gaming);
2. R-profile (real-time, 32/64-bit) -> designed for high performance hard real-time and safety critical applications (such as military, medical or avionic devices);
3. M-profile (microcontroller, 32-bit) -> targets deeply embedded systems, with applications ranging from battery powered devices that require very low power consumption to advanced image processing by providing low-latency and highly deterministic operation (ideal for time-sensitive processing).

§ The M-profile is the one of interest here! There are several M-profile versions (e.g. ARMv6-M or ARMv8-M), and the definition of each specific processor (e.g. Cortex-M0+) always includes (besides other characteristics) its ISA (aka Instruction Set Architecture) version (e.g. ARMv6-M). For instance:
- processor model "Cortex-M0+" uses ISA "ARMv6-M";
- processor model "Cortex-M7" uses ISA "ARMv7E-M".

§ An ISA is:
- a collection of (assembly/machine) instructions;
- a "contract" between hardware and software on behavior;
- NOT a definition of implementation nor a guarantee of performance -> An ISA specifies the behavior of machine code in a fashion that does not depend on the characteristics of that implementation, providing binary compatibility between implementations. This enables multiple implementations of an ISA that differ in characteristics such as performance, physical size, and monetary cost, but that are capable of running the same machine code (i.e. haveing the same behavior), so that a lower-performance, lower-cost machine can be replaced with a higher-cost, higher-performance machine without having to replace software. It also enables the evolution of the microarchitectures of the implementations of that ISA, so that a newer, higher-performance implementation of an ISA can run software that runs on previous generations of implementations.

§ The x2 main computer architectures are:
- Von Neumann, with a single/common bus for both instructions and data;
- Harvard, with separate/dedicated buses for instructions and data.
Von Neumann architecture is clearly a less complex, less space-demanding and cheaper solution, but Harvard architecture is faster (since data and instructions can be fetched in parallel, and also because the processor is provided with a cache-memory for each bus).
ARM Cortex-M processors can use both of them, depending on the specific model (e.g. Cortex-M0+ and Cortex-M7 use respectively Von Neumann and Harvard architecture).

§ Different ISAs can differ in terms of:
- number of instructions (56, 98 or else);
- availability of "thumb-instructions" (i.e. a method to compress instructions 32-bit instructions to 16-bit, if possible);
- division capability;
- availabilty of floting-point unit (single or double);
- capability of handling 64-bit results for 32-bit multiplications (i.e. safer in terms of overflow);
Anyway, note that some ISAs are just extension of previous ones (e.g. ARMv7E-M from ARMv6-M), others instead can be unrelated to each other and based on different baselines (e.g. ARMv8-M and ARMv7E).

§ The x2 most used performance-metrics (based on the Instruction-Per-Cycle estimation, aka IPC) to compare different processors/ISAs are the "DMIPS/MHz" (aka "Dhrystone Million Instructions per Second per 1-MHz clock frequency") and the "CoreMark/MHz". They're both based on the execution of a specific benchmark program (called "Dhrystone program" and "CoreMark program" respectively) to compare processors performance. Note that using the simple "MIPS" metric is reliable only when comparing MCUs of the same family: for instance, the very same task executed by an 8-bit MCU and a 32-bit MCU with the same MIPS specification, will be executed in a way smaller time by the 32-bit MCU, thus they cannot be compared just in terms of MIPS. "DMIPS/MHz" and "CoreMark/MHz" overcome this issue.

§ The term "programmer's model" indicate the processor register-model. This is actually the same for all ARM processors (e.g. Cortex-M0 or Cortex-A7) and consists of x16 32-bit CPU registers:
- R0-R7, generic command/data registers accessible to all instructions [NB: each 32-bit instruction contains bit-fields specifying "type" (e.g. jump, load, store or branch), "data" (e.g. addition operands) and "register id" (in this case, x3 bits to encode the access to one of these x8 registers)];
- R8-R12, generic command/data registers accessible to all 32-bit instructions and a few 16-bit ones [NB: requires at least x4 bits in the "register id" field];
- R13, reserved register known as "stack pointer" (SP) storing the memory address of the last data element added to the stack (or sometimes the first available address in the stack);
- R14, reserved register known as "link register" (LR) storing the return address for function calls (i.e. the address to return to when a function call completes, which must be saved into the stack before branching/jumping).
- R15, reserved register known as "program counter" (PC) - or sometimes called "instruction pointer" (IP) - storing the flash address of the next instruction to be read/executed.
- xPSR (aka Program Status Register), reserved register not directly accessible, used to automatically save stack during context switch.

§ "Binary compatibility" means that any code compiled for a specific ISA can also run unchanged for other specific ISAs (e.g. this is true between ARMv6-M and ARMv8-M), since using identical instructions. Thus, libraries (in form of binary files) can be re-used between MCU without re-compiling. Note this concept applies only to cores/CPU (e.g. for executing an algorithm), not to peripherals (since these might be mapped to different memory addresses in different MCU models).

§ A "context switch" is the process of storing the state of a process/thread before giving execution to another, so that the former can be resumed at a later point. This allows multiple processes to share a CPU, and is an essential feature of multitasking operating systems (MOS). Note that in CPUs the term "context" refers to data in registers and program counter at a specific moment in time.
In bare-metal programming, each process utilizes various CPU registers to store data and hold the current state of the running process. In MOSs, where the operating system switches between processes or threads to allow the execution of multiple processes simultaneously, for every switch the OS must save the state of the currently running process, followed by loading the next process state, which will run on the CPU. This sequence of operations that stores the state of the running process and the loading of the following running process is called "context switch". Thus, the precise meaning of the phrase "context switch" varies. In a multitasking context, it refers to the process of storing the system state for one task, so that task can be paused and another task resumed. A context switch can also occur as the result of an interrupt, such as when a task needs to access disk storage, freeing up CPU time for other tasks. Some operating systems also require a context switch to move between user mode and kernel mode tasks. The process of context switching can have a negative impact on system performance, since it's usually computationally intensive, and much of the design of operating systems is to optimize the use of context switches.
Older CPUs performed context switch entirely in hardware. However, modern CPUs perform context switches by means of software as well. A modern CPU can perform hundreds of context switches per second. Therefore, the user gets the impression that the computer is performing multiple tasks in a parallel fashion, when the CPU actually alternates or rotates between or among the tasks at a high rate of speed.

§ The "Nested Vectored Interrupt Controller" (aka NVIC) is a built-in chip that provides fast and low latency response to interrupt-driven events in Cortex-M processors (see "mcortex_architecture.jpg"). NVIC is clearly defined for each Cortex-M model and included in its architecture, and allows great cooperation and efficiency between processor core and peripherals (e.g. UART, SPI, etc).
NVIC covers any "exception" (defined as anything able to changing/deviating the regular execution flow of the code), such as "software interrupts" (caused either by a special instruction in the instruction set or by an exceptional condition in the processor itself), "reset", "interrupt requests" (IRQ), "non-maskable interrupts" (NMI, hardware interrupts that standard interrupt-masking techniques in the system cannot ignore, representing a major hardware fault), memory management, protection violation, debug events, service calls (software-triggered interrupts useful for allowing a piece of code to execute without interruption or jumping to privileged mode from the unprivileged mode).
NVIC is in charge of detecting exceptions, saving processor state into stack, update PC/R15 to ISR address corresponding to the specific exception, and once completed restoring context from stack and PC in order to resume previous execution. See an example of NVIC mapping in "nvic_mapping.png", where "Pri." = Priority ("Prg." = programmable, and -3 is the highest), "IRQx" are the peripheral interrupts (e.g. UART, SPI, etc).
Cortex-M NVICs have several powerful features:
- "Tail chaining" -> the ability to move from the execution of an ISR to another (if multiple are pending) without exiting "Handler Mode" (i.e. the exception mode); this allows to save x1 context-switch cycle, as shown in "nvic_tail_chaining.png" (here x2 different MCUs with and without this features are simulated assuming two interrupts arriving at the very same instant, resulting in 36 instruction cycles spared thanks to tail-chaining);
- "Interrupt nesting" -> the ability for a higher-priority interrupt to preempt a lower-priority interrupt currently executing (otherwise the higher-priority one should wait until the lower-priority ISR is completed to execute); see example in "nvic_interrupt_nesting.png";
- "Late arrival" -> if a higher-priority interrupt occurs during the context save of a lower priority interrupt, the processor serves the late arriving first without the need of a second context switch (i.e. sparing instruction cycles); see example in "nvic_late_arrival.png";
- "Relocatable vectore table" -> possibility to relocate the vector table (which by default resides in flash-memory at address 0x00000000) to another address via the "Vector Table Offset Register" (VTOR, i.e. the vector-table offset from default address 0x00000000); note the vector table can be this way relocated even into RAM.

§ "Interrupt latency" refers to the delay (typically measured in terms of MCU instruction cycles) between the IRQ reception (when interrupt flag is asserted) and the start of the related ISR. This delay is mainly due to context switch. A common MCU figure of merit is the so-called "jitter-free latency of the highest priority interrupt". How is it possible this latency is fixed if some instructions actually take multiple cycles to be executed? This is possible because if a multi-cycle instruction is interrupted, this is aborted to serve the higher-prioriry ISR and then it restarts from the first cycle with no penalty. In older MCU designs (before Cortex-M) instead, the interrupt was forced to wait until the current instruction was over, causing latency jitter depending on the specific interrupted instruction!

§ The "SysTick Core Timer" is a built-in chip acting as a 24-bit system timer (see "mcortex_architecture.jpg"). This is clocked by the processor clock (MCLK), and thus synchronous to processor core. It can be used to trigger interrupt for small delays or for RTOS ticks.
