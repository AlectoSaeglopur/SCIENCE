
build\target\obj\crc.o:     file format pe-i386


Disassembly of section .text:

00000000 <_Crc_ListParameters>:
 * @param[in] ioParams pointer to i/o parameters structure to be filled
 * 
 * @return error ID
 */
error_t Crc_ListParameters( crc_par_t * ioParams )
{
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	83 ec 28             	sub    $0x28,%esp
  Debug_SetWatermark((void *)Crc_ListParameters,WM_LEVEL_1);
   6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
   d:	00 
   e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  15:	e8 00 00 00 00       	call   1a <_Crc_ListParameters+0x1a>

  error_t retErr = ERR_NONE;
  1a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  if (NULL != ioParams)
  21:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  25:	0f 84 99 00 00 00    	je     c4 <_Crc_ListParameters+0xc4>
  {
    ioParams->degree = CRC_DEGREE;
  2b:	8b 45 08             	mov    0x8(%ebp),%eax
  2e:	c7 00 10 00 00 00    	movl   $0x10,(%eax)

    switch (ioParams->degree)
  34:	8b 45 08             	mov    0x8(%ebp),%eax
  37:	8b 00                	mov    (%eax),%eax
  39:	83 f8 18             	cmp    $0x18,%eax
  3c:	74 43                	je     81 <_Crc_ListParameters+0x81>
  3e:	83 f8 18             	cmp    $0x18,%eax
  41:	77 0c                	ja     4f <_Crc_ListParameters+0x4f>
  43:	83 f8 08             	cmp    $0x8,%eax
  46:	74 13                	je     5b <_Crc_ListParameters+0x5b>
  48:	83 f8 10             	cmp    $0x10,%eax
  4b:	74 21                	je     6e <_Crc_ListParameters+0x6e>
  4d:	eb 6b                	jmp    ba <_Crc_ListParameters+0xba>
  4f:	83 f8 20             	cmp    $0x20,%eax
  52:	74 40                	je     94 <_Crc_ListParameters+0x94>
  54:	83 f8 40             	cmp    $0x40,%eax
  57:	74 4e                	je     a7 <_Crc_ListParameters+0xa7>
  59:	eb 5f                	jmp    ba <_Crc_ListParameters+0xba>
    {
      case CRC_DEGREE_8:
        ioParams->pGenPoly = CRC_GENPOLY_8;
  5b:	8b 45 08             	mov    0x8(%ebp),%eax
  5e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
        ioParams->lenGenPoly = sizeof(CRC_GENPOLY_8);
  65:	8b 45 08             	mov    0x8(%ebp),%eax
  68:	c6 40 08 05          	movb   $0x5,0x8(%eax)
        break;
  6c:	eb 5d                	jmp    cb <_Crc_ListParameters+0xcb>

      case CRC_DEGREE_16:
        ioParams->pGenPoly = CRC_GENPOLY_16;
  6e:	8b 45 08             	mov    0x8(%ebp),%eax
  71:	c7 40 04 05 00 00 00 	movl   $0x5,0x4(%eax)
        ioParams->lenGenPoly = sizeof(CRC_GENPOLY_16);
  78:	8b 45 08             	mov    0x8(%ebp),%eax
  7b:	c6 40 08 03          	movb   $0x3,0x8(%eax)
        break;
  7f:	eb 4a                	jmp    cb <_Crc_ListParameters+0xcb>

      case CRC_DEGREE_24:
        ioParams->pGenPoly = CRC_GENPOLY_24;
  81:	8b 45 08             	mov    0x8(%ebp),%eax
  84:	c7 40 04 08 00 00 00 	movl   $0x8,0x4(%eax)
        ioParams->lenGenPoly = sizeof(CRC_GENPOLY_24);
  8b:	8b 45 08             	mov    0x8(%ebp),%eax
  8e:	c6 40 08 05          	movb   $0x5,0x8(%eax)
        break;
  92:	eb 37                	jmp    cb <_Crc_ListParameters+0xcb>

      case CRC_DEGREE_32:
        ioParams->pGenPoly = CRC_GENPOLY_32;
  94:	8b 45 08             	mov    0x8(%ebp),%eax
  97:	c7 40 04 10 00 00 00 	movl   $0x10,0x4(%eax)
        ioParams->lenGenPoly = sizeof(CRC_GENPOLY_32);
  9e:	8b 45 08             	mov    0x8(%ebp),%eax
  a1:	c6 40 08 0e          	movb   $0xe,0x8(%eax)
        break;
  a5:	eb 24                	jmp    cb <_Crc_ListParameters+0xcb>

      case CRC_DEGREE_64:
        ioParams->pGenPoly = CRC_GENPOLY_64;
  a7:	8b 45 08             	mov    0x8(%ebp),%eax
  aa:	c7 40 04 20 00 00 00 	movl   $0x20,0x4(%eax)
        ioParams->lenGenPoly = sizeof(CRC_GENPOLY_64);
  b1:	8b 45 08             	mov    0x8(%ebp),%eax
  b4:	c6 40 08 04          	movb   $0x4,0x8(%eax)
        break;
  b8:	eb 11                	jmp    cb <_Crc_ListParameters+0xcb>

      default:
        retErr = ERR_INV_CRC_DEGREE;
  ba:	c7 45 f4 0e 00 00 00 	movl   $0xe,-0xc(%ebp)
        break;
  c1:	90                   	nop
  c2:	eb 07                	jmp    cb <_Crc_ListParameters+0xcb>
    }
  }
  else
  {
    retErr = ERR_INV_NULL_POINTER;
  c4:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
  }

  return Error_HandleErr(retErr);
  cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
  ce:	89 04 24             	mov    %eax,(%esp)
  d1:	e8 00 00 00 00       	call   d6 <_Crc_ListParameters+0xd6>
}
  d6:	c9                   	leave  
  d7:	c3                   	ret    

000000d8 <_Crc_CalculateChecksum>:
 * @param[in] pParams pointer to crc parameters structure
 * 
 * @return error ID
 */
error_t Crc_CalculateChecksum( const byte_stream_t * inStream, byte_stream_t * outStream, const crc_par_t * pParams )
{
  d8:	55                   	push   %ebp
  d9:	89 e5                	mov    %esp,%ebp
  db:	53                   	push   %ebx
  dc:	83 ec 44             	sub    $0x44,%esp
  df:	89 e0                	mov    %esp,%eax
  e1:	89 c3                	mov    %eax,%ebx
  Debug_SetWatermark((void *)Crc_CalculateChecksum,WM_LEVEL_1);
  e3:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  ea:	00 
  eb:	c7 04 24 d8 00 00 00 	movl   $0xd8,(%esp)
  f2:	e8 00 00 00 00       	call   f7 <_Crc_CalculateChecksum+0x1f>

  error_t retErr = ERR_NONE;
  f7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  const ulen_t crcLenBy = BI2BY_LEN(pParams->degree);
  fe:	8b 45 10             	mov    0x10(%ebp),%eax
 101:	8b 00                	mov    (%eax),%eax
 103:	c1 e8 03             	shr    $0x3,%eax
 106:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  const ulen_t upLenBi = BY2BI_LEN(inStream->len)+pParams->degree;    /** upshifted bit-length */
 109:	8b 45 08             	mov    0x8(%ebp),%eax
 10c:	8b 40 04             	mov    0x4(%eax),%eax
 10f:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
 116:	8b 45 10             	mov    0x10(%ebp),%eax
 119:	8b 00                	mov    (%eax),%eax
 11b:	01 d0                	add    %edx,%eax
 11d:	89 45 e0             	mov    %eax,-0x20(%ebp)
  const ulen_t upLenBy = BI2BY_LEN(upLenBi);                          /** upshifted byte-length */
 120:	8b 45 e0             	mov    -0x20(%ebp),%eax
 123:	c1 e8 03             	shr    $0x3,%eax
 126:	89 45 dc             	mov    %eax,-0x24(%ebp)
  slen_t maxDeg, quotDeg;
  ulen_t byteIdx;
  byte_t tmpPoly[upLenBy];                                            /** temporary polynomial used for iterative division operations */
 129:	8b 45 dc             	mov    -0x24(%ebp),%eax
 12c:	83 e8 01             	sub    $0x1,%eax
 12f:	89 45 d8             	mov    %eax,-0x28(%ebp)
 132:	b8 10 00 00 00       	mov    $0x10,%eax
 137:	8d 50 ff             	lea    -0x1(%eax),%edx
 13a:	8b 45 dc             	mov    -0x24(%ebp),%eax
 13d:	01 d0                	add    %edx,%eax
 13f:	b9 10 00 00 00       	mov    $0x10,%ecx
 144:	ba 00 00 00 00       	mov    $0x0,%edx
 149:	f7 f1                	div    %ecx
 14b:	6b c0 10             	imul   $0x10,%eax,%eax
 14e:	e8 00 00 00 00       	call   153 <_Crc_CalculateChecksum+0x7b>
 153:	29 c4                	sub    %eax,%esp
 155:	8d 44 24 0c          	lea    0xc(%esp),%eax
 159:	83 c0 00             	add    $0x0,%eax
 15c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  uint8_t mask;
  uint8_t bitIdx;
  uint8_t j;

  if (Memory_IsStreamValid(inStream,inStream->id) &&
 15f:	8b 45 08             	mov    0x8(%ebp),%eax
 162:	8b 40 08             	mov    0x8(%eax),%eax
 165:	89 44 24 04          	mov    %eax,0x4(%esp)
 169:	8b 45 08             	mov    0x8(%ebp),%eax
 16c:	89 04 24             	mov    %eax,(%esp)
 16f:	e8 00 00 00 00       	call   174 <_Crc_CalculateChecksum+0x9c>
 174:	84 c0                	test   %al,%al
 176:	0f 84 10 02 00 00    	je     38c <_Crc_CalculateChecksum+0x2b4>
      Memory_IsStreamValid(outStream,outStream->id) &&
 17c:	8b 45 0c             	mov    0xc(%ebp),%eax
 17f:	8b 40 08             	mov    0x8(%eax),%eax
 182:	89 44 24 04          	mov    %eax,0x4(%esp)
 186:	8b 45 0c             	mov    0xc(%ebp),%eax
 189:	89 04 24             	mov    %eax,(%esp)
 18c:	e8 00 00 00 00       	call   191 <_Crc_CalculateChecksum+0xb9>
  if (Memory_IsStreamValid(inStream,inStream->id) &&
 191:	84 c0                	test   %al,%al
 193:	0f 84 f3 01 00 00    	je     38c <_Crc_CalculateChecksum+0x2b4>
      Memory_IsStreamValid(outStream,outStream->id) &&
 199:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
 19d:	0f 84 e9 01 00 00    	je     38c <_Crc_CalculateChecksum+0x2b4>
      (NULL != pParams))
  {
    if (crcLenBy == outStream->len)
 1a3:	8b 45 0c             	mov    0xc(%ebp),%eax
 1a6:	8b 40 04             	mov    0x4(%eax),%eax
 1a9:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
 1ac:	0f 85 d1 01 00 00    	jne    383 <_Crc_CalculateChecksum+0x2ab>
    {
      memcpy(tmpPoly,inStream->pBuf,inStream->len);                     /** upshift the message polynomial into tmpPoly(x) */
 1b2:	8b 45 08             	mov    0x8(%ebp),%eax
 1b5:	8b 48 04             	mov    0x4(%eax),%ecx
 1b8:	8b 45 08             	mov    0x8(%ebp),%eax
 1bb:	8b 10                	mov    (%eax),%edx
 1bd:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 1c0:	89 4c 24 08          	mov    %ecx,0x8(%esp)
 1c4:	89 54 24 04          	mov    %edx,0x4(%esp)
 1c8:	89 04 24             	mov    %eax,(%esp)
 1cb:	e8 00 00 00 00       	call   1d0 <_Crc_CalculateChecksum+0xf8>
      memset(&tmpPoly[inStream->len],0,crcLenBy);
 1d0:	8b 45 08             	mov    0x8(%ebp),%eax
 1d3:	8b 50 04             	mov    0x4(%eax),%edx
 1d6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 1d9:	01 c2                	add    %eax,%edx
 1db:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 1de:	89 44 24 08          	mov    %eax,0x8(%esp)
 1e2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 1e9:	00 
 1ea:	89 14 24             	mov    %edx,(%esp)
 1ed:	e8 00 00 00 00       	call   1f2 <_Crc_CalculateChecksum+0x11a>
      maxDeg = upLenBi-FindMaxDegree(tmpPoly,upLenBi)-1;                /** search for the maximum degree of tmpPoly(x) at 1st iteration */
 1f2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 1f5:	8b 55 e0             	mov    -0x20(%ebp),%edx
 1f8:	89 54 24 04          	mov    %edx,0x4(%esp)
 1fc:	89 04 24             	mov    %eax,(%esp)
 1ff:	e8 a1 01 00 00       	call   3a5 <_FindMaxDegree>
 204:	89 c2                	mov    %eax,%edx
 206:	8b 45 e0             	mov    -0x20(%ebp),%eax
 209:	29 d0                	sub    %edx,%eax
 20b:	83 e8 01             	sub    $0x1,%eax
 20e:	89 45 f0             	mov    %eax,-0x10(%ebp)
      quotDeg = maxDeg-pParams->degree;                                 /** estimate quotient degree at 1st iteration */
 211:	8b 55 f0             	mov    -0x10(%ebp),%edx
 214:	8b 45 10             	mov    0x10(%ebp),%eax
 217:	8b 00                	mov    (%eax),%eax
 219:	29 c2                	sub    %eax,%edx
 21b:	89 d0                	mov    %edx,%eax
 21d:	89 45 ec             	mov    %eax,-0x14(%ebp)

      if (maxDeg < upLenBi)                                             /** verify that input stream is not an all-zero array */
 220:	8b 45 f0             	mov    -0x10(%ebp),%eax
 223:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 226:	0f 83 2f 01 00 00    	jae    35b <_Crc_CalculateChecksum+0x283>
      {
        while (quotDeg >= 0)
 22c:	e9 20 01 00 00       	jmp    351 <_Crc_CalculateChecksum+0x279>
        {                                                               /** exit if at current iteration tmpPoly(x) has a maximum degree less than CrcDeg */
          byteIdx = BI2BY_LEN(upLenBi-maxDeg-1);
 231:	8b 45 f0             	mov    -0x10(%ebp),%eax
 234:	8b 55 e0             	mov    -0x20(%ebp),%edx
 237:	29 c2                	sub    %eax,%edx
 239:	89 d0                	mov    %edx,%eax
 23b:	83 e8 01             	sub    $0x1,%eax
 23e:	c1 e8 03             	shr    $0x3,%eax
 241:	89 45 d0             	mov    %eax,-0x30(%ebp)
          bitIdx = (uint8_t)((upLenBi-maxDeg-1)&LSBYTE_MASK_U32);
 244:	8b 45 e0             	mov    -0x20(%ebp),%eax
 247:	89 c2                	mov    %eax,%edx
 249:	8b 45 f0             	mov    -0x10(%ebp),%eax
 24c:	29 c2                	sub    %eax,%edx
 24e:	89 d0                	mov    %edx,%eax
 250:	83 e8 01             	sub    $0x1,%eax
 253:	83 e0 07             	and    $0x7,%eax
 256:	88 45 cf             	mov    %al,-0x31(%ebp)
          mask = ~(MSBIT_MASK_U8>>bitIdx);
 259:	0f b6 45 cf          	movzbl -0x31(%ebp),%eax
 25d:	ba 80 00 00 00       	mov    $0x80,%edx
 262:	89 c1                	mov    %eax,%ecx
 264:	d3 fa                	sar    %cl,%edx
 266:	89 d0                	mov    %edx,%eax
 268:	f7 d0                	not    %eax
 26a:	88 45 ce             	mov    %al,-0x32(%ebp)
          tmpPoly[byteIdx] &= mask;                                     /** reset the maximum degree of tmpPoly(x) at current iteration */
 26d:	8b 55 d4             	mov    -0x2c(%ebp),%edx
 270:	8b 45 d0             	mov    -0x30(%ebp),%eax
 273:	01 d0                	add    %edx,%eax
 275:	0f b6 00             	movzbl (%eax),%eax
 278:	22 45 ce             	and    -0x32(%ebp),%al
 27b:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
 27e:	8b 55 d0             	mov    -0x30(%ebp),%edx
 281:	01 ca                	add    %ecx,%edx
 283:	88 02                	mov    %al,(%edx)
          for (j=0; j<pParams->lenGenPoly; j++)
 285:	c6 45 eb 00          	movb   $0x0,-0x15(%ebp)
 289:	e9 85 00 00 00       	jmp    313 <_Crc_CalculateChecksum+0x23b>
          {
            byteIdx = BI2BY_LEN(upLenBi-quotDeg-pParams->pGenPoly[j]-1);
 28e:	8b 45 ec             	mov    -0x14(%ebp),%eax
 291:	8b 55 e0             	mov    -0x20(%ebp),%edx
 294:	89 d1                	mov    %edx,%ecx
 296:	29 c1                	sub    %eax,%ecx
 298:	8b 45 10             	mov    0x10(%ebp),%eax
 29b:	8b 50 04             	mov    0x4(%eax),%edx
 29e:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
 2a2:	01 d0                	add    %edx,%eax
 2a4:	0f b6 00             	movzbl (%eax),%eax
 2a7:	0f b6 c0             	movzbl %al,%eax
 2aa:	29 c1                	sub    %eax,%ecx
 2ac:	89 c8                	mov    %ecx,%eax
 2ae:	83 e8 01             	sub    $0x1,%eax
 2b1:	c1 e8 03             	shr    $0x3,%eax
 2b4:	89 45 d0             	mov    %eax,-0x30(%ebp)
            bitIdx = (uint8_t)((upLenBi-quotDeg-pParams->pGenPoly[j]-1)&LSBYTE_MASK_U32);
 2b7:	8b 45 e0             	mov    -0x20(%ebp),%eax
 2ba:	89 c2                	mov    %eax,%edx
 2bc:	8b 45 ec             	mov    -0x14(%ebp),%eax
 2bf:	89 d1                	mov    %edx,%ecx
 2c1:	29 c1                	sub    %eax,%ecx
 2c3:	8b 45 10             	mov    0x10(%ebp),%eax
 2c6:	8b 50 04             	mov    0x4(%eax),%edx
 2c9:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
 2cd:	01 d0                	add    %edx,%eax
 2cf:	0f b6 00             	movzbl (%eax),%eax
 2d2:	29 c1                	sub    %eax,%ecx
 2d4:	89 c8                	mov    %ecx,%eax
 2d6:	83 e8 01             	sub    $0x1,%eax
 2d9:	83 e0 07             	and    $0x7,%eax
 2dc:	88 45 cf             	mov    %al,-0x31(%ebp)
            mask = (MSBIT_MASK_U8>>bitIdx);
 2df:	0f b6 45 cf          	movzbl -0x31(%ebp),%eax
 2e3:	ba 80 00 00 00       	mov    $0x80,%edx
 2e8:	89 c1                	mov    %eax,%ecx
 2ea:	d3 fa                	sar    %cl,%edx
 2ec:	89 d0                	mov    %edx,%eax
 2ee:	88 45 ce             	mov    %al,-0x32(%ebp)
            tmpPoly[byteIdx] ^= mask;                                   /** compute division remainder at current iteration */
 2f1:	8b 55 d4             	mov    -0x2c(%ebp),%edx
 2f4:	8b 45 d0             	mov    -0x30(%ebp),%eax
 2f7:	01 d0                	add    %edx,%eax
 2f9:	0f b6 00             	movzbl (%eax),%eax
 2fc:	32 45 ce             	xor    -0x32(%ebp),%al
 2ff:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
 302:	8b 55 d0             	mov    -0x30(%ebp),%edx
 305:	01 ca                	add    %ecx,%edx
 307:	88 02                	mov    %al,(%edx)
          for (j=0; j<pParams->lenGenPoly; j++)
 309:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
 30d:	83 c0 01             	add    $0x1,%eax
 310:	88 45 eb             	mov    %al,-0x15(%ebp)
 313:	8b 45 10             	mov    0x10(%ebp),%eax
 316:	0f b6 40 08          	movzbl 0x8(%eax),%eax
 31a:	3a 45 eb             	cmp    -0x15(%ebp),%al
 31d:	0f 87 6b ff ff ff    	ja     28e <_Crc_CalculateChecksum+0x1b6>
          }
          maxDeg = upLenBi-FindMaxDegree(tmpPoly,upLenBi)-1;            /** search for the maximum degree of tmpPoly(x) at current iteration */
 323:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 326:	8b 55 e0             	mov    -0x20(%ebp),%edx
 329:	89 54 24 04          	mov    %edx,0x4(%esp)
 32d:	89 04 24             	mov    %eax,(%esp)
 330:	e8 70 00 00 00       	call   3a5 <_FindMaxDegree>
 335:	89 c2                	mov    %eax,%edx
 337:	8b 45 e0             	mov    -0x20(%ebp),%eax
 33a:	29 d0                	sub    %edx,%eax
 33c:	83 e8 01             	sub    $0x1,%eax
 33f:	89 45 f0             	mov    %eax,-0x10(%ebp)
          quotDeg = maxDeg-pParams->degree;                             /** estimate the quotient degree at current iteration */
 342:	8b 55 f0             	mov    -0x10(%ebp),%edx
 345:	8b 45 10             	mov    0x10(%ebp),%eax
 348:	8b 00                	mov    (%eax),%eax
 34a:	29 c2                	sub    %eax,%edx
 34c:	89 d0                	mov    %edx,%eax
 34e:	89 45 ec             	mov    %eax,-0x14(%ebp)
        while (quotDeg >= 0)
 351:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
 355:	0f 89 d6 fe ff ff    	jns    231 <_Crc_CalculateChecksum+0x159>
        }
      }

      memcpy(outStream->pBuf,&tmpPoly[upLenBy-crcLenBy],crcLenBy);      /** copy computed crc bytes into output stream */
 35b:	8b 45 dc             	mov    -0x24(%ebp),%eax
 35e:	2b 45 e4             	sub    -0x1c(%ebp),%eax
 361:	89 c2                	mov    %eax,%edx
 363:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 366:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
 369:	8b 45 0c             	mov    0xc(%ebp),%eax
 36c:	8b 00                	mov    (%eax),%eax
 36e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 371:	89 54 24 08          	mov    %edx,0x8(%esp)
 375:	89 4c 24 04          	mov    %ecx,0x4(%esp)
 379:	89 04 24             	mov    %eax,(%esp)
 37c:	e8 00 00 00 00       	call   381 <_Crc_CalculateChecksum+0x2a9>
    if (crcLenBy == outStream->len)
 381:	eb 10                	jmp    393 <_Crc_CalculateChecksum+0x2bb>
    }
    else
    {
      retErr = ERR_INV_BUFFER_SIZE;
 383:	c7 45 f4 07 00 00 00 	movl   $0x7,-0xc(%ebp)
    if (crcLenBy == outStream->len)
 38a:	eb 07                	jmp    393 <_Crc_CalculateChecksum+0x2bb>
    }
  }
  else
  {
    retErr = ERR_INV_NULL_POINTER;
 38c:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
  }
  
  return Error_HandleErr(retErr);
 393:	8b 45 f4             	mov    -0xc(%ebp),%eax
 396:	89 04 24             	mov    %eax,(%esp)
 399:	e8 00 00 00 00       	call   39e <_Crc_CalculateChecksum+0x2c6>
 39e:	89 dc                	mov    %ebx,%esp
}
 3a0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 3a3:	c9                   	leave  
 3a4:	c3                   	ret    

000003a5 <_FindMaxDegree>:
 * @param[in] lenBi polynomial length
 * 
 * @return index of maximum degree
 */
static slen_t FindMaxDegree( const  uint8_t * poly, ulen_t lenBi )
{
 3a5:	55                   	push   %ebp
 3a6:	89 e5                	mov    %esp,%ebp
 3a8:	83 ec 28             	sub    $0x28,%esp
  Debug_SetWatermark((void *)FindMaxDegree,WM_LEVEL_2);
 3ab:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
 3b2:	00 
 3b3:	c7 04 24 a5 03 00 00 	movl   $0x3a5,(%esp)
 3ba:	e8 00 00 00 00       	call   3bf <_FindMaxDegree+0x1a>

  ulen_t j, byteIdx;
  slen_t maxDeg = -1;
 3bf:	c7 45 f0 ff ff ff ff 	movl   $0xffffffff,-0x10(%ebp)
  uint8_t bitIdx;
  
  for (j=0; j<lenBi; j++)
 3c6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 3cd:	eb 46                	jmp    415 <_FindMaxDegree+0x70>
  {
    byteIdx = BI2BY_LEN(j);
 3cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
 3d2:	c1 e8 03             	shr    $0x3,%eax
 3d5:	89 45 ec             	mov    %eax,-0x14(%ebp)
    bitIdx = (uint8_t)(j&LSBYTE_MASK_U32);
 3d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
 3db:	83 e0 07             	and    $0x7,%eax
 3de:	88 45 eb             	mov    %al,-0x15(%ebp)

    if ((poly[byteIdx]>>(BITIDX_1LAST-bitIdx))&LSBIT_MASK_U8)
 3e1:	8b 55 08             	mov    0x8(%ebp),%edx
 3e4:	8b 45 ec             	mov    -0x14(%ebp),%eax
 3e7:	01 d0                	add    %edx,%eax
 3e9:	0f b6 00             	movzbl (%eax),%eax
 3ec:	0f b6 d0             	movzbl %al,%edx
 3ef:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
 3f3:	b9 07 00 00 00       	mov    $0x7,%ecx
 3f8:	29 c1                	sub    %eax,%ecx
 3fa:	89 c8                	mov    %ecx,%eax
 3fc:	89 c1                	mov    %eax,%ecx
 3fe:	d3 fa                	sar    %cl,%edx
 400:	89 d0                	mov    %edx,%eax
 402:	83 e0 01             	and    $0x1,%eax
 405:	85 c0                	test   %eax,%eax
 407:	74 08                	je     411 <_FindMaxDegree+0x6c>
    {
      maxDeg = (slen_t)j;
 409:	8b 45 f4             	mov    -0xc(%ebp),%eax
 40c:	89 45 f0             	mov    %eax,-0x10(%ebp)
      break;
 40f:	eb 0c                	jmp    41d <_FindMaxDegree+0x78>
  for (j=0; j<lenBi; j++)
 411:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
 415:	8b 45 f4             	mov    -0xc(%ebp),%eax
 418:	3b 45 0c             	cmp    0xc(%ebp),%eax
 41b:	72 b2                	jb     3cf <_FindMaxDegree+0x2a>
    }
  }

  return maxDeg;
 41d:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 420:	c9                   	leave  
 421:	c3                   	ret    
 422:	90                   	nop
 423:	90                   	nop
