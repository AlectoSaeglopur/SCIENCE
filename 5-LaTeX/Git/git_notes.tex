
%----------------------------------------------------------------------------------------
%	PACKAGES AND DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------
\documentclass[a4paper,portrait,10pt]{article}   % set single-column layout
%\documentclass[twoside,twocolumn]{article}	  % set double-column layout
\usepackage{amssymb}
\usepackage[tbtags]{amsmath}

\usepackage{blindtext}   % Package to generate dummy text throughout this template 

\usepackage[sc]{mathpazo}   % Use the Palatino font
\usepackage[T1]{fontenc}   % Use 8-bit encoding that has 256 glyphs
\linespread{1.05}   % Line spacing - Palatino needs more space between lines
\usepackage{microtype}   % Slightly tweak font spacing for aesthetics

\usepackage[english]{babel}   % Language hyphenation and typographical rules

\usepackage[hmarginratio=1:1,top=32mm,columnsep=20pt,left=25mm]{geometry}   % Document margins
\usepackage[hang, small,labelfont=bf,up,textfont=it,up]{caption}   % Custom captions under/above floats in tables or figures
\usepackage{booktabs}   % Horizontal rules in tables

\usepackage{lettrine}   % The lettrine is the first enlarged letter at the beginning of the text

\usepackage{enumitem}   % Customized lists
\setlist[itemize]{noitemsep}   % Make itemize lists more compact

\usepackage{abstract}   % Allows abstract customization
\renewcommand{\abstractnamefont}{\normalfont\bfseries}   % Set the "Abstract" text to bold
\renewcommand{\abstracttextfont}{\normalfont\small\itshape}   % Set the abstract itself to small italic text

\usepackage{titlesec}   % Allows customization of titles
\renewcommand\thesection{\arabic{section}}   % Roman numerals for the sections
\renewcommand\thesubsection{\Roman{subsection}}   % roman numerals for subsections
\titleformat{\section}[block]{\large\scshape\centering}{\thesection.}{1em}{}   % Change the look of the section titles
\titleformat{\subsection}[block]{\large}{\thesubsection.}{1em}{}   % Change the look of the section titles

\usepackage{fancyhdr}   % Headers and footers
\pagestyle{fancy}   % All pages have headers and footers
\fancyhead{}   % Blank out the default header
\fancyfoot{}   % Blank out the default footer
\fancyhead[C]{Git Notes $\cdot$ June 2024 }   % Custom header text
\fancyfoot[C]{\thepage}   % Custom footer text
\usepackage{titling}   % Customizing the title section

\usepackage{verbatim}
\usepackage{textcomp}
\usepackage{tikz}
\usetikzlibrary{shapes,arrows}
\usepackage{circuitikz}

\usepackage{hyperref}
\hypersetup
{
  colorlinks=true,
  linkcolor=red,   % color for references
  urlcolor=violet,   % color for URLs
}

%----------------------------------------------------------------------------------------
%	CUSTOM DEFINES
%----------------------------------------------------------------------------------------

%\newcommand{\mydiv}{>> }   % divider #1
\newcommand{\mydiv}{$\Leftrightarrow$ }   % divider #2
\newcommand{\mysapo}[1]{\textquotesingle #1\textquotesingle }   % single text apostrophe
\newcommand{\mycmd}[1]{\textcolor{blue}{\textit{#1}}}   % git command style
\newcommand{\myvspace}{\vspace{4mm}}   % vertical space between sub-sections
\setlength{\leftmargini}{3.8mm}   % left margin for 1st-level itemize
\setlength{\leftmarginii}{4mm}   % left margin for 2nd-level itemize
%\newcommand{\mysecref}[1]{\hyperref[#1]{\textit{\ref{#1}. \nameref{#1}}}}   % section reference #1
\newcommand{\mysecref}[1]{\hyperref[#1]{\ref{#1}.}}   % section reference #2
\newcommand{\myurl}[2]{\href{{#1}}{\underline{\textit{#2}}}}   % url link

\newcommand{\mytzbrcolor}{black!50!green}   % branch name color for tikz graphs
\newcommand{\mytzdivcolor}{black!5!orange}   % divider color for tikz graphs
\newcommand{\mytzbrdist}{1.75cm}   % distance between consecutive branches for tikz graphs

\newcommand{\mytextfilecolor}{teal}   % color to highlight text sections within extra files


%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\setlength{\droptitle}{-4\baselineskip}   % Move the title up
\pretitle{\begin{center}\Huge\bfseries}   % Article title formatting
\posttitle{\end{center}}   % Article title closing formatting
\title{Git Notes}   % Article title
\author{
  \textsc{Filippo Valmori} \\    % Author name
  %\normalsize Alecto S\ae gl\'opur Mul.Dr. \\   % Your institution
}
\date{9\textsuperscript{th} June 2024}   % Date (leave empty to omit a date)


%----------------------------------------------------------------------------------------
%	DOCUMENT
%----------------------------------------------------------------------------------------

\begin{document}

\tikzstyle{int}=[draw, fill=white, minimum size=2em]
\tikzstyle{init} = [pin edge={to-,thin,black}]
\maketitle   % Print title

%----------------------------------------------------------------------------------
%	1. INSTALLATION
%----------------------------------------------------------------------------------

\section{Installation}   \label{sec:Install}

\begin{itemize}
\item[$\circ$] Installation procedure (tested on \textit{Windows 10} OS):
\begin{itemize}
  \item[$\cdot$] download and launch installer from Git website (free and open-source);
  \item[$\cdot$] set \textit{C:$\backslash$Program Files$\backslash$Git} as installation path;
  \item[$\cdot$] tick \textit{Open Git Bash here} and untick \textit{Open Git GUI here} within \textit{Windows Explorer integration};
\item[$\cdot$] select \textit{Use Visual Studio Code as Git's default editor};
\item[$\cdot$] select \textit{Let Git decide} about default branch naming;
\item[$\cdot$] select \textit{Git from command line and also from 3rd-party software};
\item[$\cdot$] select \textit{Use bundled OpenSSH};
\item[$\cdot$] select \textit{Use the OpenSSL library};
\item[$\cdot$] select \textit{Checkout Windows-style, commit Unix-style line endings};
\item[$\cdot$] select \textit{Use MinTTY};
\item[$\cdot$] select \textit{Fast-forward or merge} as pull-command behavior;
\item[$\cdot$] select \textit{Git Credential Manager};
\item[$\cdot$] tick \textit{Enable file system caching}
\item[$\cdot$] skip the \textit{Experimental options} window and start the installation.
\end{itemize}
\end{itemize}
\myvspace

%--------------------------------------------------------------------------
%	2. SETUP
%--------------------------------------------------------------------------

\section{Setup}   \label{sec:Setup}

\begin{itemize}
\item[$\circ$] User's name and email configuration:
\begin{itemize}
  \item[$\cdot$] to configure Git username \mydiv \mycmd{git config -{}-global user.name "<name>"} (e.g. \textit{Filippo Valmori});
  \item[$\cdot$] to configure Git email \mydiv \mycmd{git config -{}-global user.email "<email>"} (e.g. \textit{filippo.valmori@gmail.com});
  \item[$\cdot$] \textbf{NB \#1}: for the last two commands, \textit{-{}-system} or \textit{-{}-local} could be used in place of \textit{--global} to (however that's in general not recommended, see Coursera's training for more details);
  \item[$\cdot$] to readback set user's name and email \mydiv \mycmd{git config user.name} and \text{git config user.email} (or all at once via \mycmd{git config [-{}-global] -{}-list});
  \item[$\cdot$] to avoid line-ending issues among team members working with different OSs and automatically convert \mysapo{CRLF} (typical of Windows) line-endings into \mysapo{LF} (typical of Linux and macOS) when adding a file to the index (and vice versa when it checks out code onto your filesystem) \mydiv \mycmd{git config -{}-global core.autocrlf true} (in particular, when asserted on Windows machines, this converts \mysapo{LF} endings into \mysapo{CRLF} when you check out code);
  \item[$\cdot$] \textbf{NB \#2}: \mysapo{CR} = \mysapo{\textbackslash r} = \textit{Carriage Return} character | \mysapo{LF} = \mysapo{\textbackslash n} = \textit{Line Feed} character.
\end{itemize}
\myvspace

\item[$\circ$] SSH key generation for encrypting and authenticating communication from/to server (assuming ED25519 algorithm):
\begin{itemize}
  \item[$\cdot$] open Git bash (anywhere);
  \item[$\cdot$] type \mycmd{ssh-keygen -t ed25519 -C "<email>"};
  \item[$\cdot$] empty-ENTER until completion;
  \item[$\cdot$] check public (.pub) and private keys have been successfully created in the specified (hidden) folder \textit{.ssh} (e.g. \textit{C:$\backslash$Users$\backslash$Filippo$\backslash$.ssh});
  \item[$\cdot$] from internet browser, go to \textit{github website > profile icon > settings/manage-account > ssh keys} and upload the authentication public-key just created (simply drag-and-drop it);
  \item[$\cdot$] as a confirmation, type on bash \textit{git gui} to open Git GUI and here go to \textit{help > show ssh key} and verify the key has been successfully loaded;
  \item[$\cdot$] \textbf{NB \#3}: setting up the SSH key is helpful because it allows to automatically authenticate yourself when accessing the remote server, thus without the need of supplying your username and password at each visit. For further details see \myurl{https://confluence.atlassian.com/bitbucketserverkb/ssh-rsa-key-rejected-with-message-no-mutual-signature-algorithm-1026057701.html}{here}.
\end{itemize}
\end{itemize}
\myvspace

%--------------------------------------------------------------------------
%	3. LOCATIONS & SYNTAX
%--------------------------------------------------------------------------

\section{Locations \& Syntax}   \label{sec:LocatSyntax}

\begin{itemize}
\item[$\circ$] Locally on each developer's PC the so-called \textit{project directory} folder contains:
\begin{itemize}
  \item[$\cdot$] \textbf{\textit{working tree}} (WT), where the actual project files and directories (relative to a single commit at each time) are placed and can be edited;
  \item[$\cdot$] \textbf{\textit{staging area}} (SA, sometimes called also \textit{index}), where the file planned to be part of the next commit are stored (aka \textit{staged});
  \item[$\cdot$] \textbf{\textit{local repository}} (LR), storing all the commits of the project (thus, representing its versioning history).
\end{itemize}
\myvspace

\item[$\circ$] Note locally SA and LR are located inside the hidden sub-directory \textit{.git}. Thus, removing this folder means removing all the project version history locally.
\myvspace

\item[$\circ$] The \textbf{\textit{remote repository}} (RR), unlike the other three mentioned above, is located remotely in a single data-center or cloud and represents the common interaction point among all developers (thus it identifies the official state of the project at any time). When LR and RR are synchronized, they contain exactly the same commits.
\myvspace

\item[$\circ$] The general syntax for commands is \mycmd{git command [-{}-flags] [arguments]} or, more in detail, \mycmd{git command (-f|-{}-flag) [<id>] [<paths> ...]}, where:
\begin{itemize}
  \item[$\cdot$] \textit{|} = alternative;
  \item[$\cdot$] \textit{[]} = optional values;
  \item[$\cdot$] \textit{-} or \textit{-{}-} = command flag or option;
  \item[$\cdot$] \textit{<>} = required values (aka \textit{placeholder});
  \item[$\cdot$] \textit{()} = grouping (for better clarity and disambiguation);
  \item[$\cdot$] \textit{...} = multiple occurrences possible.
\end{itemize}
\end{itemize}
\myvspace

%--------------------------------------------------------------------------
%	4. CREATE NEW LOCAL REPOSITORY
%--------------------------------------------------------------------------

\section{Create new local repository}   \label{sec:NewLR}

\begin{itemize}
\item[$\circ$] If the repository does not exist remotely on GitHub website yet:
\begin{itemize}
  \item[$\cdot$] create a folder where to place all repositories (e.g. \textit{repos\_ folder});
  \item[$\cdot$] move inside the folder and create an empty sub-folder named after the new project to be created (e.g. \textit{proj\_ xyz});
  \item[$\cdot$] move inside the sub-folder, open a bash and initialize the LR \mydiv \mycmd{git init};
  \item[$\cdot$] verify the \textit{.git/} hidden folder has been successfully \mydiv \mycmd{ls -a};
  \item[$\cdot$] now work on the repository by adding, modifying and/or removing files;
  \item[$\cdot$] \textbf{NB \#1}: for new repositories it is good practise to add a \textit{README.md} file to project main path (if not existing yet).
\end{itemize}
\end{itemize}
\myvspace

%--------------------------------------------------------------------------
%	5. COMMIT TO LOCAL REPOSITORY
%--------------------------------------------------------------------------

\section{Commit to local repository}   \label{sec:CommitLR}

\begin{itemize}
\item[$\circ$] Useful commands for committing:
\begin{itemize}
  \item[$\cdot$] to check if there are files/directories modified or untracked in respect of the last commit \mydiv \mycmd{git status [-s]};
  \item[$\cdot$] to add desired untracked or modified files/directories (and in turn all files inside the latter) to SA \mydiv \mycmd{git add <files-or-directories>};
  \item[$\cdot$] alternatively, to add all untracked, modified and deleted files/directories to SA without specifying them one by one \mydiv \mycmd{git add -{}-all|-A};
  \item[$\cdot$] to move all staged files/directories from SA to LR (i.e. adding a new snapshot/node representing the current state of the project to the version history) \mydiv \mycmd{git commit -m "<comment>"};
  \item[$\cdot$] to verify WT and SA have been cleaned of all committed files/directories \mydiv \mycmd{git status};
  \item[$\cdot$] finally check the LR commit-history of the current branch via \textit{git log} (see Section \mysecref{sec:GitLog});
  \item[$\cdot$] \textbf{NB \#1}: to delete a current branch commit in LR \mydiv \mycmd{git reset -{}-hard <commit\_id>} (or \mycmd{git reset -{}-hard HEAD\textasciitilde X} to cancel last X commits, assuming HEAD is pointing to latest commit of the desired local branch);
  \item[$\cdot$] \textbf{NB \#2}: to examine changes more in detail and select one by one the files to stage and commit use Git GUI (see Section \mysecref{sec:GitGui}).
\end{itemize}
\myvspace

\item[$\circ$] Not all modified and untracked files in the WT have to be staged and then part of the next commit. Typical examples are the \textit{.o}, \textit{.map}, \textit{.bin}, \textit{.srec} or \textit{.exe} files generated after building, since only \textit{.c} and \textit{.h} source files are actually included in the versioning (assuming not to include them in any \textit{.gitignore} file).
\end{itemize}
\myvspace

%--------------------------------------------------------------------------
%	6. PUSH TO REMOTE REPOSITORY
%--------------------------------------------------------------------------

\section{Push to remote repository}   \label{sec:PushRR}

\begin{itemize}
\item[$\circ$] In case LR exists (see Section \mysecref{sec:NewLR} and \mysecref{sec:CommitLR}) and RR does not yet:
\begin{itemize}
  \item[$\cdot$] open an internet browser and create a new empty repository on GitHub website with the same name of that in your LR (e.g. \textit{proj\_xyz});
  \item[$\cdot$] open bash inside LR and link it to RR through its URL address (retrievable at \textit{github website > prj\_xyz > code > HTTPS/SSH}) \mydiv \mycmd{git remote add <prj\_name> <url>} (e.g. \textit{<prj\_name>} = \textit{origin} or \textit{proj\_xyz}, and \textit{<url>} = \textit{https://github.com/AlectoSaeglopur/proj\_xyz} or \textit{git@github.com:AlectoSaeglopur/proj\_xyz.git});
  \item[$\cdot$] \textbf{NB \#1}: using SSH addresses is always recommended if SSH key has been already generated and linked for the user (see Section \mysecref{sec:Setup});
  \item[$\cdot$] initialize RR according to current LR state \mydiv \mycmd{git push -u|-{}-set-upstream <rr\_name> <branch>} (e.g. \textit{git push -u origin master}, or more specifically \textit{git push -{}-set-upstream proj\_xyz master}).
\end{itemize}
\myvspace

\item[$\circ$] In case RR already exists and LR does not yet:
\begin{itemize}
  \item[$\cdot$] clone RR to LR \mydiv \mycmd{git clone <url>} (as already mentioned, SSH addresses are recommended, thus use HTTPS only if SSH does not work);
  \item[$\cdot$] now work on the repository by adding, modifying and/or removing files;
  \item[$\cdot$] commit desired changes to LR (see Section \mysecref{sec:CommitLR});
  \item[$\cdot$] push current LR state to RR \mydiv \mycmd{git push}.
\end{itemize}
\end{itemize}
\myvspace

%--------------------------------------------------------------------------
%	7. OBJECTS & IDS
%--------------------------------------------------------------------------

\section{Objects \& IDs}   \label{sec:ObjIds}

\begin{itemize}
\item[$\circ$] Git provides four main types of so-called \textit{objects}:
\begin{itemize}
  \item[$\cdot$] \textbf{\textit{commit}} \mydiv representing a snapshot of the repository at a particular point in time;
  \item[$\cdot$] \textbf{\textit{annotated tag}} \mydiv representing a permanent reference to a commit (typically used for software releases);
  \item[$\cdot$] \textbf{\textit{tree}} \mydiv used to create the hierarchy between files and directories within a repository;
  \item[$\cdot$] \textbf{\textit{blob}} \mydiv where the actual content of project files is stored.
\end{itemize}
\myvspace
  
\item[$\circ$] Typically the user has to care only about commits and annotated tags, whereas trees and blobs are handled internally and hiddenly by Git itself.
\myvspace

\item[$\circ$] The specific name of a Git object is called \textit{ID} (aka \textit{hash} or \textit{checksum}), consisting of a 40-character hexadecimal string generated through the SHA-1 encryption algorithm (e.g. the IDs of all commits related to a branch can be seen via \textit{git log}). However, IDs are often shortened to the first seven characters to make their visualization more user-friendly (e.g. as they are shown via \textit{git log -{}-oneline}).
\myvspace

\item[$\circ$] For each commit Git automatically create and associates a unique ID (generated through an avalanche principle part of the SHA-1, i.e. producing massive differences on the hash value even for minimal changes on repository files), so to guarantee consistency-check.
\end{itemize}
\myvspace

%--------------------------------------------------------------------------
%	8. REFERENCES & TAGS
%--------------------------------------------------------------------------

\section{References \& Tags}   \label{sec:RefsTags}

\begin{itemize}
\item[$\circ$] A commit can be associated with a \textbf{\textit{reference}}, namely a user-friendly name (e.g. \textit{HEAD} or \textit{master}) pointing to a commit hash (e.g. 64a0c2b...) or another reference (aka \textit{symbolic reference} in this latter case). Therefore, references can be used instead of hashes for simplicity's sake.
\myvspace

\item[$\circ$] Each branch is assigned with a so-called \textbf{\textit{branch-label}}, a reference with the same name of the branch (e.g. \textit{develop} or \textit{master}) pointing always to the most recent commit of that branch (aka \textit{tip of the branch}). Note that \textit{master} is the default name of the main branch in every repository (thus also the \textit{master}-reference does exist for any repository).
\myvspace

\item[$\circ$] All references are automatically stored and updated within \textit{.git/refs/heads/} and they are nothing but files named after the corresponding local branch and containing inside their current local hash/commit value. The only exception is \textit{HEAD}, which is kept within \textit{.git/}.
\myvspace

\item[$\circ$] The \textit{HEAD}-reference points to the branch-commit pair currently present in the WT (thus, it can exist only one \textit{HEAD} per repository). By default it is usually equal to the \textit{branch-label} (e.g. \textit{master} or \textit{develop}), but unlike the latter this can be also moved back to previous commits of the branch via \mycmd{git checkout <commit\_id>}. For example, assuming to be in the \textit{master} branch, if using \textit{git log -{}-oneline} returns that \textit{HEAD} points to \textit{master} (i.e. \textit{HEAD $\rightarrow$ master}), then using \textit{git checkout HEAD\textasciitilde} (i.e. \textit{git checkout <previous\_commit\_id>}) moves \textit{HEAD} one commit back and updates the WT accordingly (thus now \textit{master} becomes one commit ahead of \textit{HEAD}). Executing now \textit{git checkout master} resets \textit{HEAD} equal to \textit{master} (i.e. to the latest commit of the branch).
\myvspace

\item[$\circ$] The \mysapo{\textasciitilde} and \mysapo{\textasciicircum} characters can be used to refer to previous commits. In particular, \mysapo{\textasciitilde} allows to refer to single-parent commits, whereas \mysapo{\textasciicircum} to multiple-parent commits (i.e. in case of merge-commits). For example:
\begin{itemize}
  \item[$\cdot$] to show latest four commits of current branch (e.g. \textit{develop}) \mydiv \textit{git log -{}-online -4};
  \item[$\cdot$] to print detailed info about last commit (assuming \textit{HEAD$\rightarrow$master}) \mydiv \textit{git show HEAD} (expected to return the same commit ID shown as 1\textsuperscript{st} entry by the aforementioned \textit{git log} command);
\item[$\cdot$] to print detailed info about second-last commit \mydiv \textit{git show HEAD\textasciitilde 1} or \textit{git show HEAD\textasciitilde} (expected to return the same commit shown as 2\textsuperscript{nd} entry by the aforementioned \textit{git log} command);
\item[$\cdot$] to print detailed info about third-last commit \mydiv \textit{git show HEAD\textasciitilde 2} or \textit{git show HEAD\textasciitilde\textasciitilde} (expected to return the same commit shown as 3\textsuperscript{rd} entry by the aforementioned \textit{git log} command);
\item[$\cdot$] ...
\end{itemize}
\myvspace

\item[$\circ$] \textbf{\textit{Tags}} are references attached to specific commits, acting as a sort of user-friendly labels for these commits. Thus, tags can be used in place of branch-labels or IDs for Git commands (verifiable via \textit{git show <tag\_name>}). There are two types of tags:
\begin{itemize}
  \item[$\cdot$] \textbf{\textit{lightweight}}, a simple reference to the commit (just like branch-labels or \textit{HEAD}) with no additional information;
  \item[$\cdot$] \textbf{\textit{annotated}}, a full object referencing the commit (including tag's author, date, message and commit ID), which can be optionally even signed and verified via GPG (aka \textit{GNU Privacy Guard}), and typically used for code-releases.
\end{itemize}
\myvspace

\item[$\circ$] Useful commands for tags:
\begin{itemize}
  \item[$\cdot$] to create a new \textit{lightweight tag} \mydiv \mycmd{git tag <tag\_name> [<commit\_id>]} (e.g. \textit{git tag v.3.1.8} automatically linked to \textit{HEAD});
  \item[$\cdot$] to create a new \textit{annotated tag} \mydiv \mycmd{git tag -a [-m "<message>" | -F <file>] <tag\_name> [<commit\_id>]} (e.g. \textit{git tag -a -m "release for EMC tests" v.3.1.8} or \textit{git tag -a -F my\_message.txt v.3.1.8 f318bd7});
  \item[$\cdot$] to check the tag has been successfully associated to the desired commit \mydiv \textit{git log -{}-oneline -{}-graph}; 
  \item[$\cdot$] to delete a tag locally \mydiv \mycmd{git tag -d <tag\_name>} (e.g. \textit{git tag -d v.1.3.8});
  \item[$\cdot$] to delete a tag remotely \mydiv \mycmd{git push <remote> -d <tag\_name>} (e.g. \textit{git push origin -d v.1.3.8});
  \item[$\cdot$] \textbf{NB \#1}: if not specified, \textit{<commit\_id>} is always linked by default to \textit{HEAD} for all tag-commands;
  \item[$\cdot$] to check details of the created tag \mydiv \textit{git show <tag\_name>};
  \item[$\cdot$] to show all repository tags created \mydiv \mycmd{git tag}.
\end{itemize}
\myvspace

\item[$\circ$] Keep in mind the \textit{git push} command does not automatically transfer tags to RR:
\begin{itemize}
  \item[$\cdot$] to transfer a single tag to RR \mydiv \mycmd{git push <remote> <tag\_name>} (e.g. \textit{git commit origin v.3.1.8});
  \item[$\cdot$] to transfer all of your tags to RR \mydiv \textit{git push <remote> -{}-tags} [NOT RECOMMENDED];
  \item[$\cdot$] note unfortunately tags are not show in GitHub network-graph, but can be displayed by clicking the dedicated button on the main page of the project (from here also formal releases can be created, giving the chance to add the corresponding binaries as well).
\end{itemize}
\end{itemize}
\myvspace

%--------------------------------------------------------------------------
%	9. IGNORE & RM
%--------------------------------------------------------------------------

\section{Ignore}   \label{sec:Ignore}

\begin{itemize}
\item[$\circ$] The purpose of the \textbf{\textit{.gitignore}} file is to prevent specific files within the Git repository from being part of the versioning. In particular, to keep some WT files/directories out of Git versioning since the beginning of the project without removing them locally from the WT (e.g. build files generated after compilation, that usually are not versioned), add them as new lines to the \textit{.gitignore} file present in the main page of the WT. For example:
\begin{itemize}
  \item[] \textcolor{\mytextfilecolor}{\textit{build/}}
  \item[] \textcolor{\mytextfilecolor}{\textit{source/test.log}}
\end{itemize}
\myvspace

\item[$\circ$] It is possible to create additional \textit{.gitignore} files inside project sub-folders to simplify the handling of the files path to be ignored. For example, to exclude from versioning the file \textit{source/hal/adc.h} you can either add the entry \textcolor{\mytextfilecolor}{\textit{source/hal/adc.h}} within the main \textit{.gitignore} file of the project or add the entry \textcolor{\mytextfilecolor}{\textit{adc.h}} within the additional \textit{.gitignore} file created inside \textit{source/hal/}.
\myvspace

\item[$\circ$] To remove from versioning some files or directories which were already pushed to RR during previous commits (but still keeping them locally), remember it is not enough to add them to the \textit{.gitignore} file, since, even though you stop pushing them in future commits, they still remain stored in the RR with their previous content. Thus, they shall be removed from RR first. Follow the overall procedure hereafter:
\begin{itemize}
  \item[$\cdot$] be sure your LR branch is up-to-date with RR, there's nothing to commit, and the working tree is clean \mydiv \textit{git fetch \&\& git status};
  \item[$\cdot$] add files or directories to be excluded from versioning as new entries inside \textit{.gitignore} file;
  \item[$\cdot$] remove files or directories to be excluded from versioning from RR \mydiv \mycmd{git rm -{}-cached <file>} or \mycmd{git rm -r -{}-cached <directory>} (e.g. \textit{git rm -{}-cached source/xyz.c} or \textit{git rm -r -{}-cached bin/});
  \item[$\cdot$] \textbf{NB \#1}: the previous command can be alternatively executed over the whole LR via \textit{git rm -r cached .} [NOT RECOMMENDED, since it may create issues in case the project contains submodules];
  \item[$\cdot$] stage changes (i.e. files or directories excluded from versioning according to updated \textit{.gitignore}) \mydiv \textit{git add -{}-all} (or more specifically \textit{git add <files-or-directories>});
  \item[$\cdot$] commit changes \mydiv \textit{git commit -m "apply .gitignore updates"};
  \item[$\cdot$] push changes to RR \mydiv \textit{git push};
  \item[$\cdot$] open RR on GitHub website and verify the specified files OR directories have been removed from the project;
  \item[$\cdot$] as a check, try to modify within WT a file just excluded from versioning and then verify via \textit{git status} that it is not reported anymore as \textit{modified}].  
\end{itemize}
\myvspace

\item[$\circ$] The \textit{-{}-cached} option specifies the removal should happen only on the staging index, leaving WT files untouched. On the other hand, executing \textit{git rm <file>} without the \textit{-{}-cached} option physically deletes the files from WT and automatically stages the change (i.e. it is equivalent to delete the file manually and then execute \textit{git add <file>}).
\myvspace

\item[$\circ$] Instead, if some project files or directories are no more needed and thus can be completely deleted both locally and remotely, the procedure is easier and similar to usual commits:
\begin{itemize}
  \item[$\cdot$] delete files or directories (i.e. move to recycle bin);
  \item[$\cdot$] stage changes \mydiv \textit{git add <files-or-directories>};
  \item[$\cdot$] commit changes \mydiv \textit{git commit -m "files removed"};
  \item[$\cdot$] push changes to RR \mydiv \textit{git push}.
\end{itemize}
\myvspace

\item[$\circ$] To create exceptions for specific \textit{.gitignore} entries use the \mysapo{!} character. For example, adding the following two lines inside the \textit{.gitignore} file cause all \textit{.cpp} files within the repository to be excluded from versioning except for \textit{src/xyz.cpp}:
\begin{itemize}
  \item[] \textcolor{\mytextfilecolor}{\textit{*.cpp}}
  \item[] \textcolor{\mytextfilecolor}{\textit{!src/xyz.cpp}}
\end{itemize}
\end{itemize}
\myvspace

%--------------------------------------------------------------------------
%	10. BRANCHES
%--------------------------------------------------------------------------

\section{Branches}   \label{sec:Branches}

\begin{itemize}
\item[$\circ$] Every commit belongs to a specific branch (Git's default one is named \textit{master}), which contains the history of all commits related to that branch. Branches are created by reference and they are essential useful for code experimentation, testing, development within a team (since they allow concurrent and independent work on the same project without mutual interference), and for supporting multiple project-versions (in case of need for customization between different applications or clients).
\myvspace

\item[$\circ$] Branches can be of two types:
\begin{itemize}
  \item[$\cdot$] \textbf{\textit{long-lived}} (aka \textit{base}), related to stable and official versions of the project over time (such as \textit{master} or \textit{develop});
  \item[$\cdot$] \textbf{\textit{short-lived}} (aka \textit{topic}), related to tickets that shortly merge back to a \textit{long-lived} branch (such as \textit{bugfix}, \textit{hotfix} or \textit{feature}).
\end{itemize}
\myvspace

\item[$\circ$] Useful commands for branches:
\begin{itemize}
  \item[$\cdot$] to show all local branches of the project \mydiv \mycmd{git branch};
  \item[$\cdot$] \textbf{NB \#1}: among the results shown by executing \textit{git branch}, the branch marked with the \mysapo{*} character represents the one currently pointed by \textit{HEAD}, thus the one present within WT at that time;
  \item[$\cdot$] to create a new branch locally \mydiv \mycmd{git branch <branch\_name>};
  \item[$\cdot$] \textbf{NB \#2}: before creating a new branch (e.g. \textit{bugfix\_startup\_327}) be sure to checkout to the desired source branch (e.g. \textit{develop});
  \item[$\cdot$] to push a new branch just created in LR to RR \mydiv \mycmd{git push -u origin <branch\_name>} (where \textit{-u} = \textit{-{}-set-upstream});
  \item[$\cdot$] \textbf{NB \#3}: new branches can be also created on RR first (go to \textit{github website > project\_name > view all branches > new branch} and select the source branch), then locally use \textit{git fetch} to check and retrieve new branches from RR (and now by executing \textit{git branch} it can be verified the new branch is listed locally as well);
  \item[$\cdot$] \textbf{NB \#4}: a new branch keeps inside also the whole previous history of its source branch (easily verifiable via \textit{git log}).
\end{itemize}
\myvspace

\item[$\circ$] The \textit{checkout} command can be used to:
\begin{itemize}
  \item[$\cdot$] switch \textit{HEAD} from the current branch-commit pair to either the tip of another branch-label or another commit ID of the same branch-label \mydiv \mycmd{git checkout <branch>} or \mycmd{git checkout <commit\_id>};
  \item[$\cdot$] update the WT with files and directories from the checked out branch or commit;
  \item[$\cdot$] be allowed to commit for that branch locally and remotely (i.e. to both LR and RR);
  \item[$\cdot$] \textbf{NB \#5}: the commands \textit{git branch <new\_branch> \&\& git checkout <new\_branch>} can be combined into a single one (assuming \textit{<new\_branch>} does not exist yet locally) \mydiv \mycmd{git checkout -b <new\_branch>}.
\end{itemize}
\myvspace

\item[$\circ$] Whenever \textit{HEAD} within the current branch does not point to its branch-label (i.e. tip of the branch) but to one of its previous commits, that causes the so-called \textbf{\textit{detached HEAD}} situation. Keep in mind if you want to work restarting from a previous commit (e.g. \textit{HEAD\textasciitilde}) you shall first create a dedicated branch and checkout to that, otherwise it would create a \textit{HEAD-detached conflict}.
\myvspace

\item[$\circ$] Use \mycmd{git branch -d <branch\_name>} to locally delete a branch. Keep in mind deleting a branch actually means deleting its branch-label. Moreover, note the command fails if the branch to be deleted is the one currently pointed by \textit{HEAD} (thus checkout to another first) or is \textit{dangling} (i.e. it has commits which have not been merged back yet to any \textit{long-lived} branch). To solve the latter, you can decide to either merge it back or force its deletion via \textit{git branch -D <branch\_name>}. To revert an accidental branch deletion use \textit{git reflog} (showing LR list of recent HEAD commits) to read the commit ID of the deleted dangling branch to be restored and then use \textit{git checkout -b <branch\_name> <commit\_id>}. Remember that Git periodically checks in background withing the project the presence of dangling commits (i.e. commits not linked to a branch anymore, since the latter has been deleted) and delete (aka \textit{garbage collect}) them automatically. Finally, to delete the branch also remotely on RR use \mycmd{git push origin -d <branch\_name>} (where \textit{-d} = \textit{-{}-delete}).
\end{itemize}
\myvspace

%--------------------------------------------------------------------------
%	11. MERGING
%--------------------------------------------------------------------------

\section{Merging}   \label{sec:Merging}

\begin{itemize}
\item[$\circ$] Merging allows to combine the work of independent branches (usually from a \textit{short-lived} branch into a \textit{long-lived} one). There exist four types of merging:
\begin{itemize}
  \item[$\cdot$] \textit{fast-forward};
  \item[$\cdot$] \textit{merge commit};
  \item[$\cdot$] \textit{squash merge};
  \item[$\cdot$] \textit{rebase merge}.
\end{itemize}

\item[$\circ$] \textbf{\textit{Fast-forward}} (FF) moves directly the source branch-label to the tip of the destination branch without causing conflicts (therefore, it is possible only if no overlapping commits or unstaged changes have been added to the source branch in the meanwhile). In this case, after merging both branches contain exactly the same commits, thus the destination branch inherits all the source branch commits (even in case later the destination branch gets deleted). With FF merging the resulting \textit{commit history} (aka \textit{commit graph}) is linear, namely no commits have multiple parents (verifiable visually via \textit{git log -{}-oneline -{}-graph}). Hereafter the procedure to perform an FF merging:
\begin{itemize}
  \item[$\cdot$] commit and push the final changes on the destination branch (aka \textit{active branch});
  \item[$\cdot$] switch to the source one (aka \textit{passive branch}) and pull latest updates (this is always a good practise, even if nothing is expected to have changed) \mydiv \textit{git checkout <source\_branch> \&\& git pull};
  \item[$\cdot$] checkout back to destination branch (i.e. where merging process is going to be applied);
  \item[$\cdot$] merge source branch into destination branch \mydiv \textit{git merge <source\_branch>};
  \item[$\cdot$] \textbf{NB \#1}: whenever using the command \textit{merge}, Git specifies the type of merging is trying to execute (e.g. by printing \textit{Fast-forward} on shell);
  \item[$\cdot$] \textbf{NB \#2}: FF is always the default type of merging attempted by Git at first;
  \item[$\cdot$] verify your destination branch is now marked as \textit{ahead of origin by 1 commit} and push merge-changes to RR \mydiv \textit{git status \&\& git push};
  \item[$\cdot$] check the source branch commits have been added to the destination branch, \textit{HEAD} points now to both branches, and commit graph is linear \mydiv \textit{git log -{}-oneline -{}-graph};
  \item[$\cdot$] if not needed anymore, delete the merged source branch both locally and remotely (see Section \mysecref{sec:Branches}) - this is not mandatory, but recommended to save space on both disk and GitHub and keep project versioning cleaner;
  \item[$\cdot$] \textbf{NB \#3}: a merged source branch is never deleted automatically by Git, it has to be done explicitly by the user via command line or GitHub website.
\end{itemize}
\myvspace

\item[$\circ$] Commit graph example for FF:
\begin{figure}[h!]
\centering
\begin{tikzpicture}[node distance=2cm,auto,>=latex']
    \node [circle,draw,scale=0.85] (A1) [] {A};
    \node [circle,draw,scale=0.85] (B1) [right of = A1, node distance=\mytzbrdist, yshift=-1.5cm] {B};
    \node [circle,draw,scale=0.85] (C1) [right of = B1, node distance=\mytzbrdist] {C};
    \node [circle,draw,scale=0.85] (?) [right of = C1, node distance=\mytzbrdist, yshift=1.5cm] {};
    
	\node [draw=none,scale=0.85,\mytzbrcolor] (Src) [below of=C1,xshift=-0.1cm,node distance=0.7cm] {\textit{Source}};
	\node [draw=none,scale=0.85,\mytzbrcolor] (Dst) [above of=A1,xshift=0.2cm,node distance=0.7cm] {\textit{Destination}};

    \path[<-] (A1) edge node[below,align=center,sloped,font=\tiny] {\textit{git branch} \\ \textit{git commit}} (B1);
    \path[<-] (B1) edge node {} (C1);
    \path[<-] (C1) edge[dashed] node[below,sloped,font=\tiny] {} (?);
    \path[<-] (A1) edge[dashed] node[above,font=\tiny] {\textit{git merge}} (?);
    
    \node [circle,draw,scale=0.85] (A2) [right of = ?, node distance=3.5cm] {A};
    \node [circle,draw,scale=0.85] (B2) [right of = A2, node distance=\mytzbrdist] {B};
    \node [circle,draw,scale=0.85] (C2) [right of = B2, node distance=\mytzbrdist] {C};
    
    \path[<-] (A2) edge node {} (B2);
    \path[<-] (B2) edge node {} (C2);
    
    \node [draw=none,scale=0.85,\mytzbrcolor] (Mrg) [below of=B2,xshift=0.5cm,node distance=0.7cm] {\textit{Destination $\equiv$ Source}};
    
    \draw[->,double,shorten <=4mm,shorten >=4mm,\mytzdivcolor] (?) -- (A2);
\end{tikzpicture}
\end{figure}

\item[$\circ$] \textbf{\textit{Merge-commit}} (MC) combines the commits at the tips of the two branches to be merged and saves the result into a new commit. A \textit{merge-commit} has always multiple parents, since represents a combination of both branches (and so generating a non-linear commit graph, verifiable via \textit{git log -{}-oneline -{}-graph}). Moreover, MC may cause conflicts if the two branches end up modifying the very same files of the project. The commands to perform an MC merge are the very same already mentioned for FF, with the only difference (assuming, for the moment, that no conflicts occur) that now a new commit is created as a result of the merging process, generating also a default commit message (modifiable if desired) explaining the specific merge details. Finally, remember it is possible to create an MC even for simpler FF cases by using \mycmd{git merge -{}-no-ff <source\_branch>}. This way, the \textit{merge-commit} will keep track also of the source branch existence. This solution generates exactly the same project files as FF would, the only difference regards the project history information. In particular, MC allows a more accurate history tracking (since source branches are not concealed), whereas FF can help to keep the history tracking cleaner. So usually it is a software team decision which policy to adopt.
\myvspace

\item[$\circ$] Commit graph example for MC (where commit \mysapo{M} contains info from \mysapo{B} and \mysapo{C} as well and these are included within destination branch history):
\begin{figure}[h!]
\centering
\begin{tikzpicture}[node distance=2cm,auto,>=latex']
    \node [circle,draw,scale=0.85] (A1) [] {A};
    \node [circle,draw,scale=0.85] (B1) [right of = A1, node distance=\mytzbrdist, yshift=-1.5cm] {B};
    \node [circle,draw,scale=0.85] (C1) [right of = B1, node distance=\mytzbrdist] {C};
    \node [circle,draw,scale=0.85] (D1) [right of = A1, node distance=\mytzbrdist] {D};
    \node [circle,draw,scale=0.85] (E1) [right of = D1, node distance=\mytzbrdist] {E};
    \node [circle,draw,scale=0.85] (?) [right of = E1, node distance=\mytzbrdist] {};
    
    \node [draw=none,scale=0.85,\mytzbrcolor] (Src) [below of=C1,xshift=-0.1cm,node distance=0.7cm] {\textit{Source}};
	\node [draw=none,scale=0.85,\mytzbrcolor] (Dst) [above of=E1,xshift=-0.1cm,node distance=0.7cm] {\textit{Destination}};
    
    \path[<-] (A1) edge node {} (D1);
    \path[<-] (D1) edge node {} (E1);
    \path[<-] (E1) edge[dashed] node[above,font=\tiny] {\textit{git merge}} (?);
    \path[<-] (A1) edge node[below,align=center,sloped,font=\tiny] {\textit{git branch} \\ \textit{git commit}} (B1);
    \path[<-] (B1) edge node {} (C1);
    \path[<-] (C1) edge[dashed] node {} (?);
    
    \node [circle,draw,scale=0.85] (A2) [right of = ?, node distance=3.5cm] {A};
    \node [circle,draw,scale=0.85] (B2) [right of = A2, node distance=\mytzbrdist, yshift=-1.5cm] {B};
    \node [circle,draw,scale=0.85] (C2) [right of = B2, node distance=\mytzbrdist] {C};
    \node [circle,draw,scale=0.85] (D2) [right of = A2, node distance=\mytzbrdist] {D};
    \node [circle,draw,scale=0.85] (E2) [right of = D2, node distance=\mytzbrdist] {E};
    \node [circle,draw,scale=0.85] (M) [right of = E2, node distance=\mytzbrdist] {M};
    
    \path[<-] (A2) edge node {} (D2);
    \path[<-] (D2) edge node {} (E2);
    \path[<-] (E2) edge node {} (M);
    \path[<-] (A2) edge node {} (B2);
    \path[<-] (B2) edge node {} (C2);
    \path[<-] (C2) edge node {} (M);

    \node [draw=none,scale=0.85,\mytzbrcolor] (Src) [below of=C2,xshift=-0.1cm,node distance=0.7cm] {\textit{Source}};
	\node [draw=none,scale=0.85,\mytzbrcolor] (Dst) [above of=M,xshift=-0.1cm,node distance=0.7cm] {\textit{Destination}};
    
    \draw[->,double,shorten <=4mm,shorten >=4mm,\mytzdivcolor] (?) -- (A2);
\end{tikzpicture}
\end{figure}

\item[$\circ$] \textbf{\textit{Squash-merge}} (SM) merges the source branch tip into the destination branch one (thus, conflict may arise in this case too). The content of the WT after SM is exactly the same as for MC, the only difference regards the final destination branch commit history. In fact, in this case the destination branch discards the source branch history after merging and considers the new commit as a single-parent one. This can help keeping the commit history cleaner, but also means losing detailed tracking information about the destination branch development. Note SM is a form of \textit{history-rewriting}. Hereafter the procedure for SM:
\begin{itemize}
  \item[$\cdot$] follow the same preliminary steps already described for FF;
  \item[$\cdot$] checkout to destination branch \mydiv \textit{git checkout <destination\_branch>};
  \item[$\cdot$] apply SM \mydiv \mycmd{git merge -{}-squash <source\_branch>};
  \item[$\cdot$] commit (deciding also whether to accept or modify the default SM message prompted).
\end{itemize}
\myvspace

\item[$\circ$] Commit graph example for SM (where commit \mysapo{S} contains info from \mysapo{B} and \mysapo{C} as well, but these are not included within destination branch history):
\begin{figure}[h!]
\centering
\begin{tikzpicture}[node distance=2cm,auto,>=latex']
    \node [circle,draw,scale=0.85] (A1) [] {A};
    \node [circle,draw,scale=0.85] (B1) [right of = A1, node distance=\mytzbrdist, yshift=-1.5cm] {B};
    \node [circle,draw,scale=0.85] (C1) [right of = B1, node distance=\mytzbrdist] {C};
    \node [circle,draw,scale=0.85] (D1) [right of = A1, node distance=\mytzbrdist] {D};
    \node [circle,draw,scale=0.85] (E1) [right of = D1, node distance=\mytzbrdist] {E};
    \node [circle,draw,scale=0.85] (?) [right of = E1, node distance=\mytzbrdist] {};
    
    \node [draw=none,scale=0.85,\mytzbrcolor] (Src) [below of=C1,xshift=-0.1cm,node distance=0.7cm] {\textit{Source}};
	\node [draw=none,scale=0.85,\mytzbrcolor] (Dst) [above of=E1,xshift=-0.1cm,node distance=0.7cm] {\textit{Destination}};
    
    \path[<-] (A1) edge node {} (D1);
    \path[<-] (D1) edge node {} (E1);
    \path[<-] (E1) edge[dashed] node[above,font=\tiny] {\textit{git merge}} (?);
    \path[<-] (A1) edge node[below,align=center,sloped,font=\tiny] {\textit{git branch} \\ \textit{git commit}} (B1);
    \path[<-] (B1) edge node {} (C1);
    \path[<-] (C1) edge[dashed] node {} (?);
    
    \node [circle,draw,scale=0.85] (A2) [right of = ?, node distance=3.5cm] {A};
    \node [circle,draw,scale=0.85] (B2) [right of = A2, node distance=\mytzbrdist, yshift=-1.5cm] {B};
    \node [circle,draw,scale=0.85] (C2) [right of = B2, node distance=\mytzbrdist] {C};
    \node [circle,draw,scale=0.85] (D2) [right of = A2, node distance=\mytzbrdist] {D};
    \node [circle,draw,scale=0.85] (E2) [right of = D2, node distance=\mytzbrdist] {E};
    \node [circle,draw,scale=0.85] (S) [right of = E2, node distance=\mytzbrdist] {S};
    
    \path[<-] (A2) edge node {} (D2);
    \path[<-] (D2) edge node {} (E2);
    \path[<-] (E2) edge node {} (S);
    \path[<-] (A2) edge node {} (B2);
    \path[<-] (B2) edge node {} (C2);

    \node [draw=none,scale=0.85,\mytzbrcolor] (Src) [below of=C2,xshift=-0.1cm,node distance=0.7cm] {\textit{Source}};
	\node [draw=none,scale=0.85,\mytzbrcolor] (Dst) [above of=M,xshift=-0.1cm,node distance=0.7cm] {\textit{Destination}};
    
    \draw[->,double,shorten <=4mm,shorten >=4mm,\mytzdivcolor] (?) -- (A2);
\end{tikzpicture}
\end{figure}

\item[$\circ$] \textbf{\textit{Rebase-merge}} (RM) is treated in Section \mysecref{sec:Rebase}.
\myvspace

\item[$\circ$] In case of long-running topic-branches, it is always a good practice to periodically merge back to the related base-branches in order not to stray too much from development progression of the latter and avoid a potentially large number of conflicts and operation mismatches.
\myvspace

\item[$\circ$] Practical case where base-branch (e.g. \textit{develop} acting as source branch) needs to be merged into a completed topic-branch (e.g. \textit{feature\_423\_bootloader} acting as destination branch) to solve conflicts locally in advance in sight of pull-request opening:
\begin{itemize}
  \item[$\cdot$] work on topic-branch, then commit and push final changes;
  \item[$\cdot$] checkout to base-branch and pull latest state from RR \mydiv \textit{git checkout <base\_branch> \&\& git pull};
  \item[$\cdot$] move back to topic-branch \mydiv \textit{git checkout <topic\_branch>};
  \item[$\cdot$] apply conditional merge (i.e. forcing MC without automatic commit) \mydiv \mycmd{git merge -{}-no-commit -{}-no-ff <base\_branch>};
  \item[$\cdot$] solve conflicts, if any (see Section \mysecref{sec:Conflicts});
  \item[$\cdot$] update submodules (only in case any reference has been changed within base-branch) \mydiv \textit{git submodule update -{}-recursive};
  \item[$\cdot$] \textbf{NB \#1}: avoid executing the previous command for submodules just updated within the topic-branch (if any, or alternatively remember to execute an additional git pull on these submodules), since topic-branch reference is supposed to be the most recent (otherwise it would mean to revert part of the topic-branch work);
  \item[$\cdot$] open Git GUI (and verify that merged files have been already staged but not committed yet), then stage, commit and push all merge changes;
  \item[$\cdot$] \textbf{NB \#2}: to revert the whole merge process (in case of any error) \mydiv \mycmd{git merge -{}-abort}.
\end{itemize}
\end{itemize}
\myvspace

%--------------------------------------------------------------------------
%	12. CONFLICTS
%--------------------------------------------------------------------------

\section{Conflicts}   \label{sec:Conflicts}

\begin{itemize}
\item[$\circ$] Conflicts arise when trying to merge branches that have modified the same sections (aka \textit{hunks}) of the same files. So, in this case the user is asked to make a decision on what to keep exactly. Note that no conflicts arise if changes have been made on separate files or even on separate hunks of the same files, since Git usually manages to resolve them autonomously.
\myvspace

\item[$\circ$] Procedure to resolve conflicts:
\begin{itemize}
  \item[$\cdot$] after merging source branch into destination one via \textit{git merge} command, if conflicts have been detected Git shows a message reporting all the project files inside which there are conflicts that cannot be automatically resolved (e.g. \textit{CONFLICT: Merge conflict in file xyz.c}), and modifies the content of these files in the WT to highlight the conflicting sections (see below);
  \item[$\cdot$] by checking now the current state of LR branch via \textit{git status} Git should answer \textit{You have unmerged paths} (giving you also the chance to abort the merge attempt via \textit{git merge -{}-abort}, which restores the WT state to the latest LR destination branch commit);
  \item[$\cdot$] to manually resolve the conflicts open corresponding files one by one with your editor (e.g. \textit{Visual Studio Code}) and solve them by deciding which branch version to keep for each unmerged section, then save and close;
  \item[$\cdot$] stage and commit the fixed files (e.g. via Git GUI);
  \item[$\cdot$] by checking now the current state of LR branch via \textit{git status} Git should answer that WT is clean and LR ahead of origin by 2 commits;
  \item[$\cdot$] push changes to RR;
  \item[$\cdot$] check via \textit{git log -{}-oneline -{}-graph} and in GitHub's \textit{Network graph} the merge has been executed successfully;
  \item[$\cdot$] optionally delete merged source branch (see Section \mysecref{sec:Branches} and \mysecref{sec:Merging});
\end{itemize}
\myvspace

\item[$\circ$] Git marks files where conflicts occurred while merging as follows:
\begin{itemize}
  \item[] \textcolor{\mytextfilecolor}{\textit{<{}<{}<{}<{}<{}<{}<}}
  \item[] \textcolor{\mytextfilecolor}{\textit{... section \#1 ... \: $\rightarrow$\: destination branch / HEAD}}
  \item[] \textcolor{\mytextfilecolor}{\textit{======= \;\;\;\;\;\;\:\:\: $\rightarrow$\: conflict divider}}
  \item[] \textcolor{\mytextfilecolor}{\textit{... section \#2 ... \: $\rightarrow$\: source branch}}
  \item[] \textcolor{\mytextfilecolor}{\textit{>{}>{}>{}>{}>{}>{}>}}
\end{itemize}
\myvspace

\item[$\circ$] To check which project files contain conflicts to be solved after a merge use \mycmd{git diff -{}-check} (if none or after solving all of them, the command simply returns no message). Plus, they are labeled as \textit{unmerged} as a result of \textit{git status}. Another way is to simply search for the string \textcolor{\mytextfilecolor}{\textit{<{}<{}<{}<{}<{}<{}< HEAD}} identifying any pending conflict throughout the project. Note conflicts can arise also due to \textit{git stash pop|apply} commands (see Section \mysecref{sec:Stash}); in this case look for the string \textcolor{teal}{\textit{>{}>{}>{}>{}>{}>{}> Stashed changes}} instead.
\end{itemize}
\myvspace

%--------------------------------------------------------------------------
%	13. TRACKING-BRANCHES
%--------------------------------------------------------------------------

\section{Tracking-Branches}   \label{sec:TrackingBranches}

\begin{itemize}
\item[$\circ$] \textbf{\textit{Tracking-branches}} (TB) are local branches representing remote branches. They are named \textit{<remote>/<branch>} (e.g. \textit{origin/master}, where \textit{origin} is a shortcut for remote repository URL/SSH address). Just after cloning a repository, the remote \textit{master} branch on GitHub and the local TB \textit{origin/master} are synchronized (i.e. containing the very same commits). However, remember TBs shall be then updated explicitly by the user to keep the synchronization. For instance, if after cloning the repository another user pushes a new commit on the same branch, RR becomes 1 commit ahead of your LR (aka \textit{decoupled}), but you cannot know this locally (e.g. via \textit{git status}) until you execute a \textit{fetch} or \textit{pull} command, since your \textit{origin/master} TB still points to the previous commit. The opposite example is when you create a new commit locally which has not been pushed yet to RR, where executing \textit{git status} returns \textit{Your branch is ahead of origin/master by 1 commit}.
\myvspace

\item[$\circ$] By default the command \textit{git branch} shows only the LR branches. Use \mycmd{git branch -{}-all} to show TBs as well, which are all unique branches stored within \textit{.git/refs/remotes/origin/} except for \textit{HEAD} (by default \textit{remotes/origin/HEAD $\rightarrow$ origin/master}). The latter is actually a symbolic reference specifying the TB related to the currently checked out branch and allowing to type only \textit{<remote>} instead of the whole \textit{<remote>/<branch>} in Git commands (e.g. \textit{origin} instead of \textit{origin/master}).
\myvspace

\item[$\circ$] Useful commands related to TBs:
\begin{itemize}
  \item[$\cdot$] to show commit-history of a remote branch (again, tracked only indirectly via the corresponding tracking-branch) \mydiv \mycmd{git log origin/<branch> [-{}-oneline]} (equivalent to simply \textit{git log origin [-{}-oneline]} if \textit{<branch>}, for instance \textit{master}, is set as default remote TB);
  \item[$\cdot$] to change locally the default remote tracking-branch (e.g. from \textit{master} to \textit{develop}, since that is usually the one where the bulk of the work is done by the team) \mydiv \mycmd{git remote set-head <remote> <branch>} (e.g. \textit{git remote set-head origin develop}, so from now on the command \textit{git log origin [-{}-oneline]} will refer to \textit{develop} commits and \textit{git branch -{}-all} will show \textit{remotes/origin/HEAD $\rightarrow$ origin/develop}).
\end{itemize}
\myvspace

\item[$\circ$] The initial default TB (e.g. corresponding to the default branch when cloning the project) can be changed for all users through \textit{github website > settings > general > default branch}. Note this is always set by default to \textit{master} for any new repository.
\myvspace

\item[$\circ$] As already mentioned above, the \textit{git status} and \textit{git log -{}-oneline -{}-graph -{}-all} commands include info about TBs status and inform you if the local branch and the corresponding TB are out of sync or not (e.g. \textit{Your branch is up-to-date with origin/master}).
\end{itemize}
\myvspace

%--------------------------------------------------------------------------
%	14. FETCH, PULL & PUSH
%--------------------------------------------------------------------------

\section{Fetch, Pull \& Push}   \label{sec:FetchPullPush}

\begin{itemize}
\item[$\circ$] Most Git commands interacts with LR only, but there are also four main \textit{network commands} in charge of communicating with the RR:
\begin{itemize}
  \item[$\cdot$] \textbf{\textit{clone}} \mydiv to copy a remote repository locally;
  \item[$\cdot$] \textbf{\textit{fetch}} \mydiv to retrieve new objects and references from RR to LR;
  \item[$\cdot$] \textbf{\textit{pull}} \mydiv to fetch and merge commits locally;
  \item[$\cdot$] \textbf{\textit{push}} \mydiv to add new object and reference from LR to RR.
\end{itemize}
\myvspace

\item[$\circ$] The \mycmd{git fetch} command allows to update local \textit{tracking-branches} with info from RR without merging the changes immediately into WT (so WT is never modified as a result of a \textit{fetch} command), thus does not affect you LR labels and just makes the user aware of the latest RR state (see Section \mysecref{sec:TrackingBranches}). In case LR is already up-to-date with RR, no info is displayed on shell after executing the command. Plus, executing \textit{git status} before and after \textit{git fetch} command allows to understand if and how LR and RR are out of sync (giving also helpful suggestions, e.g. if branch can be fast-forwarded or not in case RR is ahead by some commits). This command is also essential to get aware of and retrieve info about new branches created remotely from scratch by any user or pushed remotely by other users.
\myvspace

\item[$\circ$] The \mycmd{git pull} command combines \textit{git fetch} and \textit{git merge FETCH\_HEAD}. If any object is fetched, the tracking-branch is updated and the changes merged automatically into WT (so it may cause conflicts). Hereafter some useful merge options for the \textit{git pull} command are listed:
\begin{itemize}
  \item[$\cdot$] \textit{-{}-ff} \mydiv to fast-forward if possible, otherwise \textit{merge commit} (default if no option specified);
  \item[$\cdot$] \textit{-{}-no-ff} \mydiv to always \textit{merge commit} (even when fast-forward would be possible);
  \item[$\cdot$] \textit{-{}-ff-only} \mydiv to abort if fast-forward is not possible (i.e. avoiding merge-commit);
  \item[$\cdot$] \textit{-{}-rebase [-{}-preserve-merges]} \mydiv see Section \mysecref{sec:Rebase}.
\end{itemize}
\myvspace

\item[$\circ$] Remember to always execute \textit{git status} after each \textit{git pull}, in order to check the refreshed state of the repo. This is especially useful in case the project contains submodules to verify if any of them requires to be updated (in case, run \textit{git submodule update -{}-recursive}, see Section \mysecref{sec:Submodules}).
\myvspace

\item[$\circ$] There can be multiple situations when executing \textit{git pull}:
\begin{itemize}
  \item[$\cdot$] LR and RR in sync, without WT unstanged/uncommitted/unpushed changes \mydiv no effect;
  \item[$\cdot$] LR and RR in sync, with WT unstanged/uncommitted/unpushed changes \mydiv no effect (WT changes preserved);
  \item[$\cdot$] LR ahead of RR, without WT unstanged/uncommitted/unpushed changes \mydiv no effect;
  \item[$\cdot$] LR ahead of RR, with WT unstanged/uncommitted/unpushed changes \mydiv no effect (WT changes preserved);
  \item[$\cdot$] RR ahead of LR, without WT unstanged/uncommitted/unpushed changes \mydiv fast-forward (no conflicts);
  \item[$\cdot$] RR ahead of LR, with WT unstanged/uncommitted changes not conflicting with latest RR commits \mydiv fast-forward pull update (no conflicts and WT changes preserved);
  \item[$\cdot$] RR ahead of LR, with WT unstanged/uncommitted changes conflicting with latest RR commits \mydiv pull aborted [see \textit{PULL MESSAGE \#1}];
  \item[$\cdot$] RR ahead of LR, with LR unpushed commits having no conflicts with latest RR commits \mydiv merge-commit (no conflicts) [see \textit{PULL MESSAGE \#2}] - so in this case a new local commit is created representing the automatic combination of the latest RR commit and the unpushed LR commits (plus, a message is prompted asking the user to provide a comment for the merge), and by checking now the local state via \textit{git status} Git informs you that LR is ahead of \textit{origin/master} by 2 commits (i.e. the \textit{pull-merge} is just local for the moment);
  \item[$\cdot$] RR ahead of LR, with LR unpushed commits having conflicts with latest RR commits \mydiv merge conflict to solve [see \textit{PULL MESSAGE \#3}] - so in this case Git automatically marks the issues on the conflicting files as already reported in Section \mysecref{sec:Merging}, waiting for the user to manually resolve them (then add, commit and push) or abort the \textit{pull-merge} (again via \textit{git merge -{}-abort});
  \item[$\cdot$] \textbf{NB \#1}: always try to avoid the last situations listed above (namely generating \textit{pull-merge} conflicts) and perform \textit{git pull} with WT clean and no LR unpushed commits (thus create a new topic branch whenever a new bugfix or feature has to be added and never work directly on the base branch).
\end{itemize}
\myvspace

\item[$\circ$] \textbf{PULL MESSAGE \#1} - Aborting:
\begin{itemize}
  \item[] \textit{Updating b7b6353..bbb97e7}
  \item[] \textit{error: Your local changes to the following files would be overwritten by merge:}
  \item[] \:\: \textit{xyz.c}
  \item[] \textit{Please, commit your changes or stash them before you can merge.}
  \item[] \textit{Aborting}
\end{itemize}
\myvspace

\item[$\circ$] \textbf{PULL MESSAGE \#2} - Merge commit:
\begin{itemize}
  \item[] \textit{remote: Enumerating objects: 5, done.}
  \item[] \textit{remote: Counting objects: 100\% (5/5), done.}
  \item[] \textit{remote: Compressing objects: 100\% (1/1), done.}
  \item[] \textit{remote: Total 3 (delta 2), reused 3 (delta 2), pack-reused 0}
  \item[] \textit{Unpacking objects: 100\% (3/3), done.}
  \item[] \textit{From https://github.com/AlectoSaeglopur/proj\_16}
  \item[] \:\: \textit{4f83692..badcf67  master $\rightarrow$ origin/master}
  \item[] \textit{Merge made by the 'recursive' strategy.}
  \item[] \:\: \textit{xyz.c | 1 +}
  \item[] \:\: \textit{1 file changed, 1 insertion(+)}
\end{itemize}
\myvspace

\item[$\circ$] \textbf{PULL MESSAGE \#3} - Conflicts:
\begin{itemize}
  \item[] \textit{Auto-merging abc.txt}
  \item[] \textit{CONFLICT (content): Merge conflict in xyz.c}
  \item[] \textit{Automatic merge failed; fix conflicts and then commit the result.}
\end{itemize}
\myvspace

\item[$\circ$] The \mycmd{git push} command allows to forward commits from LR to RR for the current branch. Its basic syntax is \textit{git push [-u|-{}-set-upstream] [<repository>] [<branch>]} (see Section \mysecref{sec:PushRR} for more details). Keep in mind it is always good practice to fetch/pull before pushing in order to be aware of the latest RR state for that branch. In fact, trying to push when RR is ahead of LR by some commits simply fails (and that's why the work on a single topic branch should be done by one user only at a time for simplicity's sake) returning the following error:
\begin{itemize}
  \item[] \textit{! [rejected]   master $\rightarrow$ master (fetch first)}
  \item[] \textit{'error: failed to push some refs to origin'}
  \item[] \textit{...}
\end{itemize}
\end{itemize}
\myvspace

%--------------------------------------------------------------------------
%	15. REBASE & HISTORY REWRITING
%--------------------------------------------------------------------------

\section{Rebase \& History Rewriting}   \label{sec:Rebase}

\begin{itemize}
\item[$\circ$] ...

\end{itemize}
\myvspace






% section label to 19 as "Stash" + 20 as "Submodules" !!!

%--------------------------------------------------------------------------
%	X. GIT LOG
%--------------------------------------------------------------------------

\section{Git Log}   \label{sec:GitLog}
...

%--------------------------------------------------------------------------
%	X. GIT GUI
%--------------------------------------------------------------------------

\section{Git GUI}   \label{sec:GitGui}
...
  
%----------------------------------------------------------------------------------------
%	REFERENCE
%----------------------------------------------------------------------------------------

\begin{thebibliography}{99} % Bibliography - this is intentionally simple in this template

\bibitem[1]{bib:Sklar} B. Sklar, P. K. Ray, \textit{Digital Communications}, Chap. 4-9, Pearson Education, 2012.
 
\end{thebibliography}







%----------------------------------------------------------------------------------------

\end{document}
\grid
