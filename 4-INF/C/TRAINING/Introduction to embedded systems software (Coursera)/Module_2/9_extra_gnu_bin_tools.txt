In this video we're going to discuss some
other important tools that come with the GNU tool chain. In previous videos you learned
about many applications the GNU tool chain including the compiler,
assembler, linker, and GNU make. These are not the only tools you
can access with the GNU tool chain. There's a collection of supportive
applications referred to as the GNU project debugger and the GNU bin utils. These can be used to help evaluate,
manipulate, and even test our executable files. The Assembler and Linker are actually two
examples of the binutil applications. But these are the most popular ones. We have been invoking the Assembler and the Linker indirectly
through the use of GCC. The term the GNU Binutils is shorthand for
Binary Utilities. This term just means that the utilities
are executable binary applications. You can see in the provided list that
there are a lot of extra utilities at our disposal from the GNU tool chain. In addition, there are tools that help with debugging
that is not part of the Binutils grouping. This is the GNU Project Debugger. It is an independent
application much like Make was. We will not go into each of
the possible GNU utils and debugger applications or use. But we will highlight a few important
utility features that you may want to use. For the applications that we do not
discuss, you can look up documentation for these bin utils online. In addition, we will provide
a demo of the GNU Debugger or gdb and follow-up course material when
we get to the testing on target point. The first utility we will discuss is size. The size utility can be specialized for
each GNU toolchain. Size allows us to investigate the size of different memory sections
we are compiling. We will learn about memory management and
memory segments in later videos, but let's give a basic introduction. Each source file you compile has two types
of memory, code memory and data memory. Each of these are split up into
subsections depending on the type of code or the type of data. An example is global
verse local variables. These compiled memory sections then need
to be mapped into memory segments that we specify in the linker file. This Size Utility gives us insight into
the amount of space that is allocated for each of these sections,
given an object or an executable file. The linker should fail to
link if these are too big, or cannot fit in the allocated memory
segment given in the linker file. The Nec utility is NM from GNU binutils. This utility is used to look at
the declared symbols in an object file. As a reminder, symbols are special
identifiers for code and data in software. In addition, there are debug symbols
that will help when using the debugger to troubleshoot bugs. There are many options you can provide to
NM that allow you to sort the symbols, format the symbol table, or even print
symbols based on their locality. There are many types of symbols but
here we have shown four from the list that include code, read-only data,
initialized and uninitialized global data. The output executable contains many
different types of symbols for many files which is why
there is such a long list. Here in this example,
we have a source file called my_file.c. This file contains five
very short functions. The NM application can investigate
the object form of this file, my_file.o and determine what
types of symbols are defined. This file only contains functions
with no external include files. So all of the symbols are of type T,
or code symbols. The next utility to
discuss is object copy. This is utility is used to copy or
convert object files. This includes our output executable file,
which is a type of an object file. There are many different types of
object formats based on various manufacturers and vendors. Depending on the architecture or the
loader, specific formats would need to be used in order for a system to understand
how to install or execute an object file. Some common examples are executable
linkable format or ELFs. Common object file formats or COF. Intel Hex Record or ihex and
also the Motorola S-record or srec. Object dump is the next utility. This utility is used to
take an object file and dump information about that object file. One of the most useful information of this
tool is its ability to take an object file and dump the associated assembly code. From here a developer can investigate
subtle bugs that maybe happening at the assembly level or even analyze run
time execution down to clock cycles. The Readelf utility is specifically
helpful in understanding ELF files. ELF files are binary files
that are not human-readable. Other formats like the Intel HEX record or
Motorola S record, with some perseverance, can be decoded and mapped into
assembly because of its Hex encoding. However, ELF objects are not that way. Using the read ELF command, you can print lots of interesting
information about an ELF executable, such as size, architecture,
[INAUDIBLE] and memory sections. In this example,
we repeat the analysis of our demo program to see many different characteristics
of the file using Readelf. As you have learned in this video, there
are a lot of utilities and applications on the host machine that can help us with
building and evaluating our software. Luckily, GNU provides all of this
tools packaged together with the compiler called the GNU Binutils.