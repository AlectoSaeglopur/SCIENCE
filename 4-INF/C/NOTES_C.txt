
0. DATA-MEMORY

MCUs have typically 2 kinds of internal memories:

[a] Program-memory (aka flash), i.e. the non-volatile and slower memory where the actual code is stored. This is updated mainly at programming-time, but possibly even at run-time in case there's need to store and preserve some run-time data against power-cycles;

[b] Data-memory (aka RAM), i.e. the volatile and faster memory where data (e.g. variables) are stored and removed for run-time code execution. The data-memory is further divided into 3 sub-regions:
- Static : (Initial or final, depending on the specific MCU) region where all global variables are statically allocated (including variables defined as static inside functions and regardless of other attributes, such as static, volatile or const);
- Stack : (Middle) region where variables within functions are created and then destroyed according to a last-in-first-out (LIFO) policy. When a function or a method calls another function which in turns calls another function (etc), the execution of all those functions remains suspended until the very last function returns its value. Due to its LIFO policy, the most recently reserved block is always the next one to be freed. This makes stack-allocation and utilization very fast, since keeping track of its current utilization (through a dedicated stack-pointer) is easy, and all allocations/deallocations are done automatically;
- Heap : (Final) section dedicated to run-time dynamic allocation, whose size is typically variable and decided at programming-time (or sometimes settable a priori by the programmer through IDE, e.g. MPLAB for Microchip's dsPICs). Elements of the heap have no dependencies with each other and can always be accessed randomly at any time. You can allocate a block at any time and free it at any time. Although more flexible, this makes way more complex keeping track of which parts of the heap are allocated or free at any given time, making heap-allocation and utilization way slower than stack;


- Stack vs Heap -> Stack is recommended when you know exactly how much data you need to allocate at compile-time and this is not too size-demanding. On the other hand, heap is recommended when you don't know exactly how much data you will need at run-time or if you need to allocate size-demanding data (e.g. if you need an array with large and variable/reconfigurable size in time). Moreover, note in multi-threaded situations each thread has its own completely independent stack, but they all share the same heap. Thus, stack is thread-specific and heap is application-specific. Plus, stack memory is not resizable, meaning its allotted size cannot be changed after programming. On the contrary, heap memory can be resized at run-time. Usually the address boundary between stack and heap within the RAM is defined at compile-time (and sometimes configurable via IDE). Finally, note even though both stack and heap are "physically allocated" at run-time (i.e. the RAM partitioning between stack and heap when MCU is powered-up), the layout (i.e. the address locations) of each stack frame is decided (and stored in flash) at compile-time, unlike heap, which instead is completely handled at run-time.

------------------------------------

1. TYPEDEF

The keyword "typedef" can be used to create custom types (e.g. "typedef unsigned int MYTYPE;"), structures, unions and enumerators (see below).

------------------------------------

2. COMPILER DIRECTIVE

Every #XYZ instruction is called "compiler directive" (e.g. #include, #ifdef or #define).

Note redefining a MACRO multiple times does not cause an error: the actual value is the last encountered by the compiler. For instance, in the following example XYZ will be set to 11.

#define XYZ   (uint8_t) 5
void MyFunc( void ){
#define XYZ   (uint8_t) 11
}

------------------------------------

3. HEADER

Header files can be seen as extensions of .c files (aka "source files"), helpful to store constants, libraries or even variables used in the corresponding source files to improve code clarity.

A header file can be added in multiple ways through the #include directive:
  a) "XYZ.h" tells the pre-processor to look into the project directory (typical for custom headers defined in the same folder as the file where the directive is invoked);
  b) <XZY.h> tells the pre-processor to look into the compiler search path (typical for system/pre-defined header files, e.g. <stdint.h> or <stdio.h>);
  c) "/PATH/XYZ.h" tells the compiler to look into the specified absolute or relative path (generalization of 1st case).

Remember to use "header-guards" macros at the beginning of each header file of your project in order to prevent a single header file from being included more than once by the same compilation unit (NB: in general the compiler creates a number of compilation units equal to the number of source files included in the project). This prevents duplications and makes code more robust. The syntax is:
#ifndef HEADER_NAME_H
#define HEADER_NAME_H
...
#endif

Some useful built-in C libraries are:
- <stdio.h> for basic features (e.g. printf function),
- <stdbool.h> for boolean types,
- <stdint> for specific integer types (uint8, int32, etc),
- <string.h> for memcpy/memset functions,
- <stdlib.h> for malloc/calloc and random generation functions,
- <time.h> for getting current UTC time in seconds.

------------------------------------

4. CONSTANTS

Constants can be expressed as:
  - "literals", namely hard-coded values (typically hard to track and so called "magic numbers", such as "int x = 51"). literals can be of x4 types: integers, floating point, characters or strings;
  - "constants" (using the keywords "const" or "#define"). Note in general (since that's anyway always depending on the specific MCU) global constants are stored into program-memory (flash), whereas local one into data-memory (RAM). Strings may be an exception, since they are often placed in any case into program-memory (but that always depends on the specific compiler/linker anyway); just the pointer to the string may be stored into data-memory (see "const_table.png"). Anyway, most compilers provide attributes (not ANSI-C compliant) to specify where to store a constant. For example, to force pointer to string "xyz" to be stored into program-memory with XC32 compiler, you can write:
const char *xyz[4] __attribute__((space(prog))) = {"a11","b22","c33","d44"};

ANSI-C supports hexadecimal literals for integers (e.g. 0xCA), but not binary ones (e.g. 0b11001010). However, these are actually added and provided by most compilers.

When defining constants through macros, qualifiers are typically used to tell the compiler what size to allocate. For instance:
  - "#define XYZ 2u" creates an unsigned-short (aka uint8) constant with value 2;
  - "#define XYZ 33f" or "#define XYZ 33.0" creates a float constant with value 33;
  - "#define XYZ 1000" automatically creates a signed-long (aka uint16 or 32, depending on the compiler) with constant with value 1000.

Remember the "const" keyword actually means the defined variable (in data-memory) is read-only. However, this might be modified anyway through pointer! For example:
const int XYZ = 10;
int* pXYZ = &XYZ;			// compiler generates a warning here
printf("\n\n XYZ = %d\n",XYZ);	   	// returns 10
*pXYZ = 33;
printf("\n\n XYZ = %d\n",XYZ);		// returns 33
To solve the issues (and avoid the warning the message), pXYZ should be declared as "const int* pXYZ": now executing "*pXYZ = 33" would generate an error.

Regarding the difference and best choice between "const" and "#define":
- "const" is considered more elegant and safer in terms of data type, whereas "#define" can autonomously decide the type (unless explicitly specified);
- "#define" is slightly more efficient in case of low-optimization, since the value is physically replaced at compile-time, where "const" creates a read-only variable in memory and thus an additional memory-reading instruction each time is needed to retrieve it (however, in case of good compiler optimization, nowadays there is no difference at all);
- "#define" is needed to specified array size, since "const" cannot be used;
- "#define" is easier to use in header files (in fact, they can be easily declared just once, e.g. "#define EbN0 (float) 15.0"), whereas "const" would cause the compiler/linker to generate a multiple-definition error since the read-only variable is initialized by every source file (.c) including the header where the constant is defined (to solve the issue, the constant shall be just declared in the header - i.e.  "const float EbN0" - and then initialized in the source file - "const float EbN0 = 15.0" -, or using the not-recommended keyword "extern").

-----------------------------

5. TYPE-CONVERSION AND CASTING

Type-conversions are often performed automatically by the compiler, especially before performing operations:

int x = 5; float y = 4.0;
int z1 = x/y returns 1;
float z2 = x/y return 1.25;
In both cases x is temporarily converted to float due to y-type, the different result depends on the different z type.

int x = 5; int y = 4;
float z3 = x/y returns 1.0;
This time there was no float-conversion, since both operands are integer.

Type-casting can be also used to change temporarily the type of a variable.

The implicit type conversion (aka promotion) hierarchy (in order to avoid loss of data) is :
compiler bool -> char -> short int -> (signed) int -> unsigned int -> (signed) long -> unsigned long -> long long -> float -> double -> long double. That's why the following code:
unsigned int a = 1000;
signed int b = -1;
if( a > b )
is evaluated as false, since b is automatically casted as unsigned int resulting in 0xFFFF, which is larger than 1000. To avoid these issues, always explicitly/manually cast types (e.g. "(int)a" here).

-----------------------------

6. VARIABLE

- Declaration : int j;
- Assignment : j = 9; (or j += 1)
- Decl+Assig : int j = 9;

- Note in C (but not in C++), variables cannot be used to specify the dimension of arrays during their initialization (#define or "bare" values shall be used instead). For instance, the following code would generate a compilation error:

const uint8_t DIM = 5;
uint8_t Vect[DIM] = {0};

- Local variables are defined inside a function and valid (aka variable scope) only for that specific function. Input-variable parameters are copied and considered local as well (i.e. having higher precedence over homonymous global variables). Plus, function variables are created/destroyed inside the stack section of the RAM, whereas global variables are placed statically in a dedicated section at the beginning of the RAM.

- Always use the "u/intX_t" type declaration for variables (defined in <stdint.h>), since they are compiler-independent (thus, makes your code way more portable). Instead, for example, the generic "int" is 16-bit for XC8, but 32-bit for XC32!

-----------------------------

7. OPERATORS

~ : bitwise NOT
! : logical NOT
& : bitwise AND
&& : logical AND
| : bitwise OR
|| : logical OR
^ : bitwise XOR (aka exclusive OR)

Keep in mind precedence and associativity rules (or just use parenthesis to skip the issue).

-----------------------------

8. BIT-SHIFTING

Bit-shifting is generally more efficient than multiply (<<) or divide (>>), however it can be used only for constant powers of 2. Remember that bit-shifting a signed integer value can lead to errors if that value is negative, since the MSb is replaced by a '0' making it positive; so avoid it or insert a checking mechanism to set MSb to '1' if the original value was negative.

-----------------------------

9. IF-SWITCH STATEMENTS

In a multiple if-elseif-else statement, the upper conditions have higher priority than the lower ones (e.g. if 1st condition is met, all others will be ignored).

In a switch statement once the condition is met, ALL the statement below are executed by default until a "break" is encountered (to avoid this behavior insert the keyword "break" at the end of each state).

To prevent "=" instead of "==" errors inside if-conditions, always place the constant as on the left. for example,
if( x == CONST ) -> error not detected by compiler!
if (CONST == x ) -> error detected by compiler!

-----------------------------

10. LOOPS

- do-while : as the usual while-loop, but executing the state before checking the condition.
- break : to break a loop (even if endless).
- continue : to jump directly to next loop execution cycle skipping all the state code left below.
- goes to : this is how it's called "-->", i.e. the combination of "--" and ">". For instance,
int cnt = 10;
while( cnt-- > 0 ){
...
}

-----------------------------

11. FUNCTION PROTOTYPE

- Note parameters name can be omitted in function prototypes (but not in the declaration, of course):

Prototype : int MySum( int A, int B ); OR int MySum( int, int );

Declaration :
int MySum( int A, int B ){
  return (A+B);
}

-----------------------------

12. STRING

- Strings can be defined as "XYZ" and automatically terminated by a NUL character (i.e. 0x00). Remember a string is treated as nothing but an array of characters in C. For example:
char MyStr[] = "vkn";
creates a 4-element string (considering the final "\0" character as well). Thus it's equivalent to:
char MyStr[] = {'v', 'k', 'n', '\0'};

- Remember a string can be modified at run-time only element-by-element, for instance:
MyStr[1] = 'A' -> OK
MyStr = "vAn" -> ERROR

-----------------------------

13. POINTER

- Direct access to variable (write) : int XYZ = 22;

- Indirect access to variable (write) : int *pXYZ = 22;

- Example #1:
int X = 99; int *Y = NULL;
Y = &X; *Y = 32;
produces the same as the instruction "X = 32".

- Example #2:
int *p;
int x[3] = {0x11,0x22,0x33};
p = x; OR p = &x[0];
causes p to point exactly to the memory location of x (i.e. x[0] = 0x11, etc).

- Remember when declaring a pointer you specify the pointed type, not the dimension of the pointer itself. For instance, assuming to use a dsPIC33 (i.e. 16-bit architecture):
float AAA = 99.9;
sizeof(AAA) -> returns "4", since by standard floats are 32-bit variables.
float *BBB;
BBB = &AAA;
sizeof(BBB) -> returns "2", since pointers represent RAM memory addresses, whose size depends on the MCU architecture size (here 16 bits = 2 bytes).
uint8_t CCC = 99.9;
sizeof(CCC) -> returns "1", since by standard uint8_t are 8-bit variables.
uint8_t *DDD;
DDD = &CCC;
sizeof(BBB) -> again returns "2" (see below).

- Remember increasing a pointer in software by using "++" (to point to the next element of the array in memory) actually increases the pointer value (representing the memory address) by the size specified in the pointer declaration. For instance, assuming to use a dsPIC33 (i.e. 16-bit architecture):
    float x[3] = {1,2,3};
    float *p;
    p = x;
    while( 1 ){
        __delay_ms(1000);
        Printf_hex16((uint16_t)p);
        p++;
    }
prints on shell 0x114A, 0x114E, 0x1152, etc, since floats have 4-byte size.
    uint8_t x[3] = {1,2,3};
    uint8_t *p;
    p = x;
    while( 1 ){
        __delay_ms(1000);
        Printf_hex16((uint16_t)p);
        p++;
    }
prints on shell 0x114A, 0x114B, 0x114C, etc, since uint8_t have 1-byte size.

- Remember that pre/post-incrementing can be executed on pointers as well, For instance:
int x[3] = {1,2,3};
int *p = &x;
int y;
y = 5+*(p++);
returns y = 6 (since expression is first evaluated and then the pointer increased) and p pointing to &x[1].

-----------------------------

14. STRUCTURE

- Structures are collections of variables grouped together under a common name, and each sub-field is called "member";

- there are x3 ways to define and create instances of a structure (but 3rd is the recommended one):
[1] struct complex_t {
    float real;
    float imag;
} Var1, Var2;
[2] struct complex_t {
    float real;
    float imag;
}
...
struct complex_t x,y;
[3] typedef struct {
    floar real;
    float imag;
} complex_t;
...
complex_t Var1, Var2;

- Members can be assigned during initialization or later:
complex_t Var1 = {0.4, 5.1};
Var1.real = -2.9;
complex_t *pVar2 = &Var1;
pVar2->imag = 8.4; 

- "Bit-fields" are special kind of members. Here the bit-width of each member can be specified, making it useful to esily bit-access a varible with no need for masking operations. Note the dimension allocated for a bit-fields structure varies depending on the specific compiler! 

-----------------------------

15. UNION

- Unions are similar to structures, but all their members share the same memory location. Thus, a union is essentially a variable capable of holding different types of data at different times. The size of a union is equal to that of its largest member. Note that, unlike for structures, modifying a union member means modifying also all others now, since they actually all refer to the same memory location actually!

- For example, unions can be used to choose between the overall value of a variable or its bit-fields (see the "struct_unions.c" script).

-----------------------------

16. ENUMERATOR

- Enumerators create a mapping between a limited range of integer values and the corresponding symbolic constants. They have a syntax similar to structures/union, and they make code more readable (especially in case of state machines). By default, values always start from 0 and increase by one each time; however, the programmer can also force their values (and then successive values will keep increasing from there). For instance:
typedef enum {
    MON,		// 0
    TUE,		// 1
    WED = 5,		// 5
    THU,		// 6
    FRI, 		// 7
    SAT = 13,    	// 13
    SUN			// 14
} weekday_t;

- Keep in mind C allows you to set an enum-variable even outside the type range. For example, considering the example just above, using "weekday_t today = 66;" would be correctly executing without generating any error.
 
-----------------------------

17. STATE MACHINE

Software state machine can be created using enumerators along with a switch-case or a functions-array (see "state_machine.c"). The switch-case approach is easy to maintain and does not require pointers (thus, issues related to accidental pointers corruption in data-memory are avoided); on the other hand, the function approach is more portable and structured, but might suffer from pointers corruption in the data-memory (this can be counteracted by using the qualifier "const" or watchdogs).

-----------------------------

18. VOLATILE

When a variable is declared with the qualifier "volatile", the compiler generates code that ensures that every access to the variable reads or writes its actual value, rather than using any cached or optimized value. Without the volatile keyword, the compiler may optimize the code by assuming that the value of the variable will not change, and it may reuse the previous value read from the variable instead of reading its current value. This optimization can cause incorrect behavior if the value of the variable changes unexpectedly. Note that defining variables as volatile reduces the code performance, thus shall be used only if really needed. Declaring a variable as "volatile" makes sense for the following cases:
[a] to access memory-mapped peripheral registers which may change in any moment asynchronously to the program flow (e.g. a register storing the state of some digital GPIOs);
[b] to access variables (usually global variables) that can be modified during ISRs (typical of embedded programming);
[c] to access variables shared among several tasks (typical of multi-thread programming; for example, if two tasks have to exchange information via a shared memory location, all shared global variables should be declared volatile on both sides);
[d] to prevent counter optimization when implementing software delay-functions.

-----------------------------

19. FLOATING-POINT

MCUs can basically handle floating-point arithmetic in x2 ways:
[a] using an additional hardware module called floating-point unit (FPU), which is designed and optimized exactly for floating-point operations -> faster and more efficient, but also more expensive and space-demanding due to the additional hardware;
[b] using software libraries to replicate the FPU operation -> way slower, but cheaper and less-space demanding since no additional hardware is needed.

-----------------------------

20. IMPLICIT TYPE PROMOTION

C was designed to implicitly and silently change the integer types of the operands used in expressions. This causes the compiler to promote (aka cast) all integer formats smaller than "int" (e.g. bool, u/int8_t and u/int16_t for 32-bit MCUs) to "signed int" automatically during operations. The rationale behind this is to prevent accidental overflows during arithmetic, but also to allow operands with different signedness to co-exist in the same expression. Unfortunately, the rules for implicit type promotion cause much more harm than good, to the point where they might be one of the biggest flaws in the C language. For instance,
uint8_t X = 0x55;
uint16_t Y = ~X;
printf("%X\n",Y);
generates "FFAA" instead of the expected "00AA". This is because, before applying the bitwise-NOT, X is implicitly converted to int (i.e. "0x00000055", assuming 32-bit architecture). Then ~X produces "FFFFFFAA", and finally "FFAA" after the uint16_t casting. To get the expected result (i.e. "00AA"), the instruction should have been "uint16_t Y = (uint8_t)(~X)".
In any case, the best practise in these cases is always to manually add the type-casting, avoiding issues caused by C implicit promotion. See "implicit_type_promotion.pdf" for further details.

-----------------------------

21. SEQUENCE POINT

Sequence points refer to issues and side effects that might arise by misunderstanding how the compiler translates your code into instructions (especially in terms of order). For example:
[a] if( j++ < 10 || i++ < 5 ) -> in this case, if the 1st condition is met, the 2nd one is not even evaluated, thus "i" might be never increased;
[b] add(i+1,i=j+2) -> in this case, there's no certainty the 1st argument will be evaluated before being updated by the 2nd one, since the compiler can evaluate the arguments of a function in any order (in fact, the compiler typically generates a warning in these cases);
[c] a = f(i++)+g(i)+h(i--) -> in this case, there's no certainty the update of the variable "i" will follow the written order, since the compiler can decide to call and evaluate the x3 functions in any order.

-----------------------------

22. MACRO

Macros are simply string replacements that are handled by the preprocessor.

Issues might arise if used unproperly, for example in case input expressions:
#define SQUARE(X) X*X
z = SQUARE(1+2)
actually yields z = 1+2*1+2 = 5 (and not the expected 9). To solve the issue this should be defined as "#define SQUARE(X) (X)*(X)".

Issues can also occur in case of multiple instructions, for example:
#define SWAP(a,b) a^=b; b=^a; a^=b;
if( x>5 ) SWAP(x,y);
actually always executes the last two instructions of SWAP (even if x <= 5). In this case, writing "if( x>5 ){ SWAP(x,y)};" would solve the problem.

Remember that macros cannot be debugged as standalone entities, that's why standard functions are preferred in terms of readability and safety!

-----------------------------

23. LINKED LIST DATA STRUCTURE

A linked-list is a sequence of data structures (aka nodes) which are connected together via links and typically stored into the heap memory (but also static allocation into stack is possible). Each link contains a connection to another link. Nodes can be added, deleted of moved within the list. Each node contains at least one value and one pointer.

There are x3 typical types of linked-lists:
[a] simple linked-list (SLL) -> x1+ values and x1 pointer (aka address) pointing to the next node (thus navigation is forward only), and the last item has next address equal to NULL;
[b] doubly linked-list (DLL) -> x1+ values and x2 pointers pointing to the next and previous node respectively (thus navigation can be both forward and backward), and the last item has next address equal to NULL as well as the previous address of the first item;
[c] circular linked-list (CLL) -> same as doubly case, but where the last item points to the first one as next address and the first item to the last one as previous address.

An example of SLL is:
struct Node {
    int data;
    struct Node* next;
}

The advantages of linked-lists are:
- values can be added, moved or deleted way more easily than for standard array (particularly useful in case each value is also assigned with a priority, in order not to affect the priority of the remaining elements);
- their memory size is maintained (and can be changed) dynamically at run-time (particularly useful if the array size is not fixed a priori).
The disadvantages of linked-lists are:
- extra memory space is required for the pointer members of each node;
- random access is not permitted and elements shall be accessed sequentially (e.g. to access element #3, you have to access #1 and the move to next node twice).

-----------------------------

24. DYNAMIC ALLOCATION

C provides several built-in functions for dynamic allocation in the heap section of data-memory:
[a] "ptr = malloc(byte_size)" -> allocates a single block of memory (not initialized), returns a pointer to the 1st element, and it's faster but suitable for small and simple data types;
[b] "ptr = calloc(n_elem, byte_size)" -> allocates n_elem blocks of memory (automatically initialized to 0) of the same size, returns a pointer to the 1st element, and it's slower but more suitable for big and complex data type (e.g. array of structures);
[c] "ptr = realloc(ptr, new_size)" -> to modify the size of a previously allocated memory space;
[d] "free(ptr)" -> to explicitly release/deallocate memory space previously allocated through malloc or calloc.

-----------------------------

25. FUNCTION ARGUMENTS

Remember that in C any input argument (int, pointer, structure, etc.) to a function is just a COPY of the actual variable outside! This means that changing its value inside the function actually applies the modification locally inside the function copy, but does not affect the outside original value. However, the outside value can be modified using pointer: in fact, even though the pointer address itself cannot be globally modified (as said before), actually the pointed value can, since it specifies a global RAM address.

void foo( int * ptr ){
	*ptr += 2;		// pointed value is change both locally and globally
	ptr = NULL;		// pointing address is changed only locally
}

In order to modify the pointing address, two ways are possible (see "linked_list_dynamic.c" and "linked_list_static.c" for more details):
[a] passing as input a double pointer (i.e. int ** ptr) and then modify the pointer as "*ptr = NULL":
void foo( int * ptr ){
	**ptr += 2;		// pointed value is change both locally and globally
	*ptr = NULL;		// pointing address is change both locally and globally now
}
[b] returning the pointer as output and update the global value outside the function, thus:
int *foo( int * ptr ){
	*ptr += 2;		// pointed value is change both locally and globally
	ptr = NULL;		// pointing address is changed only locally so far
	return ptr;
}
pVal = foo(pVal);

Following the discussion above, using the attribute "const" for non-pointer function arguments is not intended to protect the global value of the parameter (since it's just a copy), but to prevent the local value to be mistakenly modified inside the function (i.e. it just makes the code a little safer). In case of pointers, the second "const" (after *) acts exactly the same, but the first one (before *) can be really important in order to prevent the function from mistakenly modify any pointed value or member of the input pointer (e.g. in case of a printing-on-shell function where nothing have to be modified).

-----------------------------

26. CALLBACK

A callback is basically a function from an external library invoked through a function-pointer. Using callbacks helps increasing your project modularity, clearness and reusability. In particular, they're useful for big projects where many programmers develop different libraries and then these have to be integrated into the same main project (modularity), or in case you want to include a known and already-validated library in a new project (reusability). 

The object file XYZ.o (generated by compiling the external library) has to be added to your main project in order to include the XYZ external library functionalities. Note object files (with extension .o) are kind of "black boxes" since they are already a compiled version of the library, thus the original C source code of the library cannot be retrieve from its object file. This allows to hide and protect the actual library implementation (against intellectual property stealing or accidental modification), only providing the callbacks with their I/O definitions. This idea allows to increase modularity by practically splitting the project hierarchy into a lower-layer (aka driver-layer or hardware-layer) and higher-layer (aka application-layer). On the other hand, the only disadvantage of using object files is that they make the imported library functions hard to debug if needed, since it's not possible to debug step-by-step inside an object file.

The callback mechanism typically consists of x3 components:
[a] callback function -> function from external library called to perform as specific task. For example,
"void callback_function( void ){ ... }" and shall be defined in the external library.
NB: a callback can have any I/O types (i.e. not necessarily void as here).
[b] callback registration -> function pointer pointing to the callback function. For example,
"void (*fpointer) (void) = &callback_function;" and shall be added to the new main project. 
[c] callback execution -> function fed with a function pointer pointing to the callback function. For example,
"void callback_execution( void (*fpointer) (void) ){ ... }" and shall be added to the new main project.

There are x2 types of callbacks:
[a] polled callback -> where the callback execution (i.e. condition) is performed via polling in the main loop (see "polled_callback.c");
[b] instantaneous callback -> where the callback execution is performed via interrupt inside the ISR (aka Interrupt Service Routine);

-----------------------------

27. SPECIAL FUNCTIONS, MACROS AND TIPS

[a] Hereafter some built-in functions that can come in handy:
- char * gets(char * str) [<stdio.h>] : takes and interprets user input as characters array;
- int scanf(const char * format, ...) [<stdio.h>] : takes and interprets user input as the specified type (e.g. scanf("%d",&MyVar));
- char * strcpy(char *dst, const char *src) [<string.h>] : copies string from src to dst (returning dst, or anything else in case of error);
- void * memcpy(void * dst, const void sr, size_t n) [<string.h>] : copies n bytes from memory pointer src to dst (returning dst, or anything else in case of error); 
- void * memset(void *str, int c, size_t n) [<string.h>] : copies byte c into the first n elements of pointer str (returning str, or anything else in case of error);
- FILE *fopen(const char *filename, const char *mode) [<stdio.h>] : opens a file (.csv, .txt, etc) for read/write operation (e.g. FILE *fid = fopen("SymbsC.csv","w"), see "gaussian_fir_filter.c");
- int fprintf(FILE *fid, const char *format, ...) [<stdio.h>] : to write string into file pointed by fid (e.g. fprintf(fid,"%1.4f",MyVar));
- int fclose(FILE *stream) [<stdio.h>] : closes a file previously opened through fopen (e.g. fclose(fid));
- int rand(void) [<stdlib.h>] : returns a pseudo-random integer uniformly distributed between 0 and RAND_MAX (depending on specific hardware, but usually at least 32767).

[b] Hereafter some built-in macros that can come in handy:
- __TIME__ [preprocessor] : gets current time of the day as a string (for example, "char CurTime[sizeof(__TIME__)]; strcpy(CurTime, __TIME__);");
- __DATE__ [preprocessor] : gets current date as a string (example similar as above, see also "misc_examples.c");
- __FILE__ [preprocessor] : gets name of current file/script (example similar as above, see also "misc_examples.c");
- __LINE__ [preprocessor] : gets current code line within file/script (example similar as above, see also "misc_examples.c");
- M_PI [<math.h>] : greek pi constant (pi = 3.141593).

[c] Tips:
- use "srand(time(NULL))" [<stdlib.h>] to link the random generator seed to current machine time (see "\SCIENCE\2-TLC\CHAINS\C\extra.c");
- to compile and run a C script use "gcc -Wall FILENAME.c -o EXENAME && EXENAME", where "-Wall" enables all warning messages, "-D MACRONAME" enables the corresponding macro, and "-o XYZ" generates the corresponding .exe output (e.g. cls && gcc -Wall -D BIN_FILE IterativeCrc.c -o asd && asd); moreover, remember that in case multiple source files (.c) are included into the project, all of them shall be compiled to generate the object files (.o) and then linked together before running (e.g. "cls && gcc -c file1.c file2.c file3.c main.c && gcc file1.o file2.o file3.o main.o -o asd && asd").
