
1. TYPEDEF

Use "typedef" to create your custom type (e.g. "typedef unsigned int MYTYPE;").

------------------------------------

2. COMPILER DIRECTIVE

Every #XYZ instruction is called "compiler directive" (e.g. #include or #ifdef).
Note redifining a MACRO multiple times does not cause an error: the actual value is the last encountered by the compiler. For instance, in the following example XYZ will be set to 11.

#define XYZ 5
void MyFunc( void ){
#define XYZ 11
}

------------------------------------

3. HEADER

Header files can be seen as extensions of .c files, so to store constants, other libraries or even variables ued in the .c file (for better clarity).

A header file ca be added in multiple ways through the #define directive:
  a) "XYZ.h" tells the pre-processor to look into the project directory (typical for custom headers defined in the same folder as the file where the directive is invoked);
  b) <XZY.h> tells the pre-processor to look into the compiler search path (typical for system/pre-defined header files, e.g. <stdint.h> or <stdio.h>);
  c) "/PATH/XYZ.h" tells the compiler to look into the specified absolute or relative path (actually veryrare).

------------------------------------

4. CONSTANTS

Constants can be expressed as:
  - "literals", namely hard-coded values (typically hard to track and so called "magic numbers", such as "int x = 51"). literals can be of x4 types: integers, floating point, characters or strings;
  - "constants" (using the keywords "const" or "#define"). Note in general (since that's anyway always depending on the specific MCU) global constants are stored into program-memory (flash), whereas local one into data-memory (RAM). Strings may be an exception, since they are often placed in any case into program-memory (but that always depends on the specific compiler/linker anyway); just the pointer to the string may be stored into data-memory (see "const_table.png"). Anyway, most compilers provide attributes (not ANSI-C compliant) to specify where to store a constant. For example, to force pointer to string "xyz" to be stored into program-memory with XC32 compiler, you can write:
const char *xyz[4] __attribute__((space(prog))) = {"a11","b22","c33","d44"};

ANSI-C supports hexadecimal literals for integers (e.g. 0xCA), but not binary ones (e.g. 0b11001010). However, these are actually added and provided by most compilers.

When defining constants through macros, qualifiers are typically used to tell the compiler what size to allocate. For instance:
  - "#define XYZ 2u" creates an unsigned-short (aka uint8) constant with value 2;
  - "#define XYZ 33f" or "#define XYZ 33.0" creates a float constants with value 33;
  - "#define XYZ 1000" automatically creates a signed-long (aka uint16 or 32, depending on the compiler) with constant with value 1000.

-----------------------------

5. TYPE-CONVERSION AND CASTING

Type-conversion is sometimes performed automatically by the compiler:

int x = 5; float = 4.0;
int z1 = x/y returns 1;
float z2 = x/y return 1.25;
In both cases x is temporarily converted to float due to y-type, the different result depends on the different z type.

int x = 5; int y = 4;
float z3 = x/y returns 1.0;
This time there was no float-conversion, since both operands are integer.

Type-casting can be also used to change temporarily the type of a variable.

-----------------------------

6. VARIABLE

- Declaration : int j;
- Assignment : j = 9; (or j += 1)
- Decl+Assig : int j = 9;

- Note in C (but not in C++), variables cannot be used to specify the dimension of arrays during their initialization (#define or "bare" values shall be used instead). For instance, the following code would generate a compilation error:

const uint8_t DIM = 5;
uint8_t Vect[DIM] = {0};

- Local variables are defined inside a function and valid (aka variable scope) only for that specific function. Input-variable parameters are copied and considered local as well (i.e. having higher precedence over homonymous global variables). Plus, function varibles are created/destroyed inside the stack section of the RAM (with LIFO policy), whereas global variables are placed statically in a dedicated section at the beginning of the RAM.

- Always use the "u/intX_t" type declaration for variables (defined in <stint.h>), since they are compiler-independent (thus, makes your code way more portable). Instead, for example, the generic "int" is 16-bit for XC8, but 32-bit for XC32!

-----------------------------

7. OPERATORS

~ : bitwise NOT
! : logical NOT
& : bitwise AND
&& : logical AND
| : bitwise OR
|| : logical OR
^ : bitwise XOR (aka excluive OR)

Keep in mind precedence and associativity rules (or just use parenthesis to skip the issue).

-----------------------------

8. BIT-SHIFTING

Bit-shifting is generally more efficient than multiply (<<) or divide (>>), however it can be used only for constant powers of 2. Remember that bit-shifting a signed integer value can lead to errors if that value is negative, since the MSb is replaced by a '0' making it poitive; so avoid it or insert a checking mechanism to set MSb to '1' if the original value was negative.

-----------------------------

9. IF-SWITCH STATEMENTS
In a multiple if-elseif-else statement, the upper conditions have higher priority than the lower ones (e.g. if 1st condition is met, all others will be ignored).

In a switch statement once the condition is met, ALL the statement below are executed by default (to avoid this behavior use the keyword "break" inside each state).

-----------------------------

ยง LOOPS
do-while : as the usual while-loop, but executing the state before checking the condition.
break : to break a loop (even if endless).
continue : to jump directly to next loop execution cycle skipping all the state code left below.

-----------------------------

10. FUNCTION PROTOTYPE

- Note parameters name can be omitted in function prototypes (but not in the declaration, of course).

Prototype : int MySum( int A, int B ); OR int MySum( int, int );

Declaration :
int MySum( int A, int B ){
  return (A+B);
}

-----------------------------

11. STRING

- Strings can be defined as "XYZ" and automatically terminated by a NUL character (i.e. 0x00). Rembember a string is treated as nothing but an array of characters in C. For example:
char MyStr[] = "vkn";
creates a 4-element string (considering the final "\0" character as well). Thus it's equivalent to:
char MyStr[] = {'v', 'k', 'n', '\0'};

- Remember a string can be modified at run-time only element-by-element, for instance:
MyStr[1] = 'A' -> OK
MyStr = "vAn" -> ERROR

-----------------------------

12. POINTER

- Direct access to variable (write) : int XYZ = 22;

- Indirect access to variable (write) : int *pXYZ = 22;

- Example #1:
int X = 99; int *Y = NULL;
Y = &X; *Y = 32;
produces the same as the instruction "X = 32".

- Example #2:
int *p;
int x[3] = {0x11,0x22,0x33};
p = x; OR p = &x[0];
causes p to point exactly to the memory location of x (i.e. x[0] = 0x11, etc).

- Remember when declaring a pointer you specify the pointed type, not the dimension of the pointer itself. For instance, assuming to use a dsPIC33 (i.e. 16-bit architecture):
float AAA = 99.9;
sizeof(AAA) -> returns "4", since by standard floats are 32-bit variables.
float *BBB;
BBB = &AAA;
sizeof(BBB) -> returns "2", since pointers represent RAM memory addresses, whose size depends on the MCU architecture size (here 16 bits = 2 bytes).
uint8_t CCC = 99.9;
sizeof(CCC) -> returns "1", since by standard uint8_t are 8-bit variables.
uint8_t *DDD;
DDD = &CCC;
sizeof(BBB) -> again returns "2" (see below).

- Remember increasing a pointer in software by using "++" (to point to the next element of the array in memory) actually increases the pointer value (representing the memory address) by the size specified in the pointer declaration. For instance, assuming to use a dsPIC33 (i.e. 16-bit architecture):
    float x[3] = {1,2,3};
    float *p;
    p = x;
    while( 1 ){
        __delay_ms(1000);
        Printf_hex16((uint16_t)p);
        p++;
    }
prints on shell 0x114A, 0x114E, 0x1152, etc, since floats have 4-byte size.
    uint8_t x[3] = {1,2,3};
    uint8_t *p;
    p = x;
    while( 1 ){
        __delay_ms(1000);
        Printf_hex16((uint16_t)p);
        p++;
    }
prints on shell 0x114A, 0x114B, 0x114C, etc, since uint8_t have 1-byte size.

- Remember thet pre/post-incrementing can be executed on pointers as well, For instance:
int x[3] = {1,2,3};
int *p = &x;
int y;
y = 5+*(p++);
returns y = 6 (since expression is first evaluated and then the pointer increased) and p pointing to &x[1].

-----------------------------

13. STRUCTURE

- Structures are collections of variables grouped together under a common name, and each sub-field is called "member";

- there are x3 ways to define and create instances of a structure (but 3rd is the recommended one):
[1] struct complex_t {
    float real;
    float imag;
} Var1, Var2;
[2] struct complex_t {
    float real;
    float imag;
}
...
struct complex_t x,y;
[3] typedef struct {
    floar real;
    float imag;
} complex_t;
...
complex_t Var1, Var2;

- Members can be assigned during initialization or later:
complex_t Var1 = {0.4, 5.1};
Var1.real = -2.9;
complex_t *pVar2 = &Var1;
pVar2->imag = 8.4; 

- "Bit-fields" are special kind of members. Here the bit-width of each member can be specified, making it useful to esily bit-access a varible with no need for masking operations. Note the dimension allocated for a bit-fields structure varies depending on the specific compiler! 

-----------------------------

14. UNIONS

- Unions are similar to structures, but all their members share the same memory location. Thus, a union is essentially a variable capable of holding different types of data at different times. The size of a union is equal to that of its largest member. Note that, unlike for structures, modifying a union member means moifying also all others now, since they actually all refer to the same memory location actually!

- For example, unions can be used to choose between the overall value of a variable or its bit-fields (see the "struct_unions.c" script).
