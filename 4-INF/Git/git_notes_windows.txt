
>> 1. INSTALLATION <<

§ Installation procedure (tested on Windows 10 OS):
- launch Git.exe installer (free and open-source);
- use "C:\Program Files\Git" as installation path;
- tick "Open Git Bash here" and untick "Open Git GUI here" within "Windows Explorer integration";
- select "Use Visual Studio Code as Git's default editor";
- select "Let Git decide" about default branch naming;
- select "Git from command line and also from 3rd-party software";
- select "Use bundled OpenSSH";
- select "Use the OpenSSL library";
- select "Checkout Windows-style, commit Unix-style line endings";
- select "Use MinTTY";
- select "Fast-forward or merge" as pull-command behavior;
- select "Git Credential Manager";
- tick "Enable file system caching";
- skip the "experimental option" and start the installation.

------------------------------------------------------------

>> 2. SETUP <<

§ Configure user's name and email:
- configure Git username >> "git config --global user.name "Filippo Valmori"";
- configure Git email >> "git config --global user.email "filippo.valmori@gmail.com"";
- [for the last x2 commands, "--system" or "--local" could be used in place of "--global" to (however that's unusual, see Coursera's training for more details)];
- readback set user's name and email >> "git config user.name" and "git config user.email" (or all at once via "git config [--global] --list");
- to avoid line-ending issues among team members working with different OSs and automatically convert 'CRLF' (aka "Carriage Return" or 
typical Windows) line-endings into 'LF' (typical of Linux and macOS) when adding a file to the index (and vice versa when it checks out code onto your filesystem) use "git config --global core.autocrlf true" (in particular, when set to 'true' on Windows machines, this converts 'LF' endings into 'CRLF' when you check out code) [NB: "CR" = '\r' = "Carriage Return" character | "LF" = '\n' = "Line Feed" character].

§ To generate SSH key (using ED25519 algorithm) for encrypting/authenticating communication from/to server:
- open Git bash (anywhere);
- type "ssh-keygen -t ed25519 -C "filippo.valmori@gmail.com"" specifying your email;
- empty-ENTER until completion;
- check public (.pub) and private keys have been successfully created in the specified (hidden) folder ".ssh" (e.g. "C:\Users\Filippo\.ssh\");
- from internet browser, go to "github website > profile icon > settings/manage-account > ssh keys" and upload the authentication public-key just created (simply drag-and-drop it);
- as a confirmation, type on bash "git gui" to open Git GUI and here go to "help > show ssh key" and verify the key has been successfully loaded.
- NB: setting up the SSH key is helpful because it allows to automatically authenticate yourself when accessing the remote server, thus without the need of supplying your username and password at each visit. For further details see here "https://confluence.atlassian.com/bitbucketserverkb/ssh-rsa-key-rejected-with-message-no-mutual-signature-algorithm-1026057701.html".

------------------------------------------------------------

>> 3. LOCATIONS & SYNTAX <<

§ Locally on each developer's PC the so-called "project directory" folder contains:
- "working tree" (WT), where the actual project files and directories (relative to a single commit at each time) are placed and can be edited;
- "staging area" (SA, sometimes called also "index"), where the file planned to be part of the next commit are stored (or "staged");
- "local repository" (LR), storing all the commits of the project (thus, representing its version history).

§ Note that locally SA and LR are located inside the hidden sub-directory "/.git" (thus, removing this folder means removing all the project version history locally).

§ The "remote repository" (RR), unlike the other x3, is located remotely in a single data-center/cloud and represents the common interaction point among all developers (thus it identifies the official state of the project at any time). When LR and RR are synchronized, they contain exactly the same commits.

§ The general syntax for commands is "git [command] [--flags] [arguments]".
More in detail, "git command (-f|--flag) [<id>] [--] [<paths> ...]", where:
- '|' = or;
- '[optional]' = optional values;
- '-f' or '--flag' = command flag;
- '<placeholder>' = required value;
- '()' = grouping for clarity or disambiguation;
- '--' = to disambiguate the command;
- '...' = multiple occurrences possible.

------------------------------------------------------------

>> 4. CREATE NEW REPOSITORY LOCALLY <<

§ If project repository does not exist yet remotely on GitHub website:
- create a folder where to place all repositories (e.g. "repos_folder");
- inside the aforementioned folder, create a sub-folder for the new project to be created (e.g. "proj_1");
- here (e.g. \repos_folder\proj_1\) open a bash and initialize the LR >> "git init";
- check the ".git/" hidden folder has been successfully >> "ls -a";
- add/modify some files within the working tree...;

------------------------------------------------------------

>> 5. COMMIT TO LOCAL REPOSITORY <<

§ Useful commands for committing:
- to check if there are files/directories modified or untracked in respect of the last commit >> "git status [-s]";
- to add desired untracked or modified files/directories (and in turn all files inside the latter) to SA >> "git add [files-or-directories];
- NB: for new repositories it's good practise to add a "README.md" file to the project to the main page (if not existing yet);
- alternatively, add all untracked/modified/deleted files/directories to SA without specifying them one by one >> "git add -A" (where "-A" == "--all");
- to move all staged files/directories from SA to LR, thus adding a new snapshot/node (representing the current state of the project) to the version history >> "git commit -m "<comment>"" [NB: you can use "git commit -a -m "<comment>"" to combine "git add ." and "git commit -m "<comment>"", but keep in mind it does not work for untracked files];
- to verify WT and SA are now clean (at least of all committed files/directories) >> "git status";
- to see the LR commit-history of the current branch >> "git log [--oneline] [-X]" (e.g. X=2 can be used to show only the x2 most recent commits instead of the whole history) [NB: press 'Enter' to show more log-lines or 'q' to exit].

§ Not all modified/untracked files in the WT have to be staged and then part of the next commit/push. Typical examples are the .o/.map/.bin/.srec/.exe files generated after building, since only source files (.c/.h) are actually included in the versioning (assuming not to include them in any ".gitignore" file).

§ To delete a current branch commit in LR use "git reset --hard <commit_id>" (e.g. "git reset --hard HEAD~X" to cancel last X commits, assuming HEAD is pointing to branch-label);

------------------------------------------------------------

>> 6. PUSH TO REMOTE REPOSITORY <<

§ In case LR exists (see Section #4 and #5) and RR does not yet:
- open an internet browser and create a new empty repository on GitHub website with the same name of that in your LR (e.g. "proj_1");
- open bash inside LR and link it to RR through its URL address (e.g. "github website > PROJECT > code > HTTPS/SSH") >> "git remote add <name> <url>" (e.g. <name> = 'origin' or 'proj_1', <url> = "https://github.com/AlectoSaeglopur/proj_1" or "git@github.com:AlectoSaeglopur/proj_1.git", i.e. "git remote add origin git@github.com:AlectoSaeglopur/proj_1.git");
- [NB: using SSH addresses is always recommended if SSH key has been already generated and linked for the user (see Section #2)];
- initialize RR according to current LR state >> "git push -u|--set-upstream <repo_name> <branch>" (e.g. "git push -u origin master", or more specifically "git push --set-upstream proj_1 master").

§ In case RR already exists and LR does not yet:
- clone RR to LR >> "git clone <url>" [again, SSH addresses are recommended (use HTTPS only if SSH does not work)];
- add/modify/remove some files within the working tree...;
- commit desired changes to LR (see Section #5, e.g "git add --all && git commit -m "<comment>"";
- push current LR state to RR >> "git push".

------------------------------------------------------------

>> 7. OBJECTS & IDS <<

§ Git provides x4 main types of objects:
- commit, i.e. small text file;
- annotated tag, i.e. permanent reference to a commit;
- tree, i.e directories/filenames in the project;
- blob, content of a file in the project.
Typically the user has to care only about commits and annotated tags, whereas trees and blobs are handled internally and hiddenly by Git itself).

§ The name of a Git object is called "ID", consisting of a 40-character hexadecimal string (aka "hash" or "checksum") generated through the SHA-1 encryption algorithm (e.g. the IDs of all commits related to a branch can be seen via "git log"). Often IDs are shortened to first x7 characters to be more user-friendly (e.g. with "git log --oneline").

§ For each commit Git automatically create and associates a unique ID (aka hash), generated through an avalanche encryption-algorithm (i.e. producing huge changes on hashes even for small changes on repository files).

------------------------------------------------------------

>> 8. REFERENCES & TAGS <<

§ A commit can be associated with a "reference", i.e. a user-friendly name (e.g. 'HEAD' or 'master') pointing to a commit hash (e.g. '64a0c1...') or another reference (aka "symbolic reference" in this latter case). Therefore, references can be used instead of hashes for simplicity's sake.

§ Each branch is assigned with a so-called "branch-label", a reference with the same name of the branch (e.g. 'develop' or 'master') pointing always to the most recent commit of that branch (aka "tip of the branch"). Note that 'master' is the default name of the main branch in every repository (thus also the 'master'-reference exists for any repository).

§ All references are automatically stored/updated in "./git/refs/heads/" and they are nothing but files named as their names and containing inside the corresponding hash value. The only exception is 'HEAD', which is kept in "./git".

§ The 'HEAD'-reference points to the branch-commit pair currently present in the WT (thus, it can exist only one 'HEAD' per repository). By default it's usually equal to the "label branch" (e.g. 'master' or 'develop'), but unlike the latter this can be also moved back to previous commits of the branch using the "git checkout <commit-id>". For example, assuming to be in the 'master' branch, if using "git log --oneline" returns that 'HEAD' points to 'master' (i.e. 'HEAD->master'), then using "git checkout HEAD~" (i.e. "git checkout PREVIOUS_COMMIT_HASH") moves 'HEAD' one commit back and updates the WT accordingly (thus now 'master' becomes one commit ahead of 'HEAD'). Executing now "git checkout master" (i.e. in general "git checkout <branch-name>") resets 'HEAD' equal to 'master' (i.e. latest commit of branch).

§ The '~' and '^' characters can be used to refer to previous commits. In particular, '~' allows to refer to parent commits (i.e. in case of a single parent), whereas '^' to refer to parent in a merge-commit (i.e. in case of multiple parents). For example:
- to show latest x4 commits of current branch (e.g. 'master') >> "git log --online -4";
- to print detailed info about last commit (assuming 'HEAD->master') >> "git show HEAD" [NB: expected to return the same commit shown as 1st entry by the aforementioned "git log ..."];
- to print detailed info about second-last commit >> "git show HEAD~1" or "git show HEAD~" [NB: expected to return the same commit shown as 2nd entry by the aforementioned "git log ..."];
- to print detailed info about third-last commit >> "git show HEAD~2" or "git show HEAD~~" [NB: expected to return the same commit shown as 3rd entry by the aforementioned "git log ..."];
- ...

§ "Tags" are references attached to specific commits, acting as a sort of user-friendly labels for these commits. Thus, tags can be used instead of branch-labels or IDs for Git commands (e.g. "git show TAG_NAME"). There are x2 types of tags:
- 'lightweight', a simple reference to the commit (just like branch-labels or 'HEAD');
- 'annotated', a full object referencing the commit (including tag's author, date, message and commit ID), which can be optionally even signed and verified via GPG (aka "GNU Privacy Guard") [NB: annotated tags are typically used for code-releases].

§ Useful commands for tags:
- to create a new 'lightweight tag' >> "git tag <tag_name> [<commit>]" (e.g. "git tag v.3.1.8");
- to create a new 'annotated tag' >> "git tag -a [-m "<message>" | -F <file>] <tag_name> [<commit>]" (e.g. "git tag -a -m "release for EMC tests" v.3.1.8" or "git tag -a -m "release for EMC tests" v.3.1.8 4318bd7");
- to check the tag has been successfully associated to the desired commit >> "git log --oneline --graph"; 
- to delete a tag locally >> "git tag -d <tag_name>" (e.g. "git tag -d v.1.3.8");
- to delete a tag remotely >> "git push <remote> -d <tag_name>" (e.g. "git push origin -d v.1.3.8");
- NB: if not specified, <commit> = 'HEAD' by default for both the aforementioned commands;
- to check details of the created tag >> "git show <tag_name>";
- to show all repository tags created >> "git tag".

§ Keep in mind the "git push" command does not automatically transfer tags to RR:
- to transfer a single tag to RR >> "git push <remote> <tag_name>" (e.g. "git commit origin v.3.1.8");
- to transfer all of your tags to RR >> "git push <remote> --tags" [NOT RECOMMENDED];
- note unfortunately tags are not show in GitHub network-graph, but can be displayed by clicking the dedicated button on the main page of the project (from here also formal releases can be created, giving the chance to add the corresponding binaries as well).

------------------------------------------------------------

>> 9. GIT-IGNORE & RM <<

§ The purpose of the ".gitignore" file is to ensure that certain files not tracked by Git remain untracked. To stop tracking a file that is currently tracked, use "git rm --cached" to remove the file from the index. In particular, to keep some WT files/directories out of Git versioning since the beginning without removing them locally from the WT (e.g. build files generated after compilation, that usually are not versioned), add them to the ".gitignore" file present in the main page of the WT.

§ It's possible to create additional .gitignore files inside project sub-folders to simplify the writing/handling of the path of the files to be ignored. For example, to exclude from versioning the file "./source/hal/adc.h" you can either add the line "source/hal/adc.h" within the main .gitignore file of the project or add the line "adc.h" within the additional .gitignore file created inside "./source/hal/".

§ To remove some files/directories which were already pushed to RR during previous commits from Git versioning (but still keeping them locally), it's not enough to add them to the ".gitignore" file, since even though you stop pushing them in future commits, they still remain stored in the RR. Thus, since they shall be removed from RR first. Follow the procedure hereafter:
- be sure your local branch is up-to-date, there's nothing to commit, and the working tree is clean >> "git status";
- add files/directories to be excluded from versioning to ".gitignore";
- remove files/directories to be excluded from versioning from RR >> "git rm -r --cached <directory>" or "git rm --cached <file>" (e.g. "git rm -r --cached bin/" or "git rm --cached xyz.c");
- stage changes (i.e. files/directories excluded from versioning according to updated ".gitignore") >> "git add --all";
- [NB: the previous command can be alternatively executed over the whole LR via "git rm -r cached .", but that's not recommended since it may create issues in case the project contains submodules];
- commit changes >> "git commit -m "apply .gitignore updates"";
- push changes to RR >> "git push";
- [open the RR on GitHub website and verify the specified files/directories have been removed from the project];
- [try to modify in the WT a file just excluded from versioning and then verify via "git status" that it's not reported anymore as 'modified'].

§ Instead, if some project files/directories are no more needed and thus can be completely deleted both locally and remotely, the procedure is easier and similar to usual commits:
- delete files/directories (i.e. move to recycle bin);
- "git add --all" (or more specifically "git add <files/directories>");
- "git commit -m "files removed"";
- "git push".

§ The "--cached" option specifies the removal should happen only on the staging index, leaving WT files untouched. On the other hand, executing "git rm <file>" without the "--cached" option physically deletes the files from the WT and automatically stages the change (i.e it's equivalent to delete the file manually and then execute "git add <file_removed>"), thus operates on the current branch only (the removal event is only applied to the working directory and staging index trees, whereas the file removal is not persisted to the repository history until a new commit is created).

§ To create exceptions for specific ".gitignore" entries use the '!' character. For example, adding the following x2 lines inside the ".gitignore" file cause all '.cpp' files within the repo to be excluded from versioning except for 'src/xyz.cpp':
  *.cpp
  !src/xyz.cpp

------------------------------------------------------------

>> 10. BRANCHES <<

§ Every commit belongs to a specific branch (Git's default one is named 'master'), which contains the history of all commits related to that branch. Branches are created by reference and they are useful for code-experimentation/testing, for code development within a team (since they allow concurrent/independent work on the same project without mutual interference), and for supporting multiple project-versions (in case of customization between different applications/clients).

§ Branches can be of x2 types:
- "long-lived" (aka "base", such as 'master', 'develop' or 'release'), related to stable and official versions of the project over time;
- "short-lived" (aka "topic", such as 'bugfix', 'hotfix' or 'feature'), related to tickets that shortly merge back to a 'long-lived' branch.

§ Useful commands for branches:
- to show all branches of the project >> "git branch" (then the branch marked with the '*' character represents the one currently pointed by 'HEAD', i.e. the one present in the WT at that time) [NB: use "git fetch" before to be sure you're up-to-date with the RR];
- to create a new branch in LR >> "git branch <branch_name>" (then check this has been successfully create via "git branch") [NB: before creating a new branch (e.g. 'bugfix_startup_327') be sure to checkout to the desired source branch (e.g. 'develop')];
- to push a new branch (just created in LR) to RR >> "git push -u origin <branch_name>" [NB: '-u' = '--set-upstream'];
- [NB: new branches can be also created first on RR as well (e.g. go to "github website > PROJECT > view all branches > new branch" and choose the source-branch), then locally use "git fetch" to check if new branches are present on RR (then after executing "git checkout <new_rr_branch> && git branch" the new branch is listed also locally)].

§ The "checkout" command can be used to:
- switch 'HEAD' from the current branch-commit pair to either the checked-out branch-label (i.e. to change branch >> "git checkout <branch>") or 'commit id' (i.e. to change commit on the same branch >> "git checkout <commit>");
- update the WT with files/directories from the checked-out branch/commit;
- be able to commit for that branch locally and remotely (i.e. to both LR and RR);
- [NB: "git checkout -b <branch_name>" = "git branch <branch_name> && git checkout <branch_name>" (assuming <branch_name>-branch does not exist yet locally)].

§ Whenever 'HEAD' within the current branch does not point to the branch-label but to one of its previous commits that's called "detached HEAD". Keep in mind if you want to work restarting on a previous commit (i.e. 'HEAD~') you have to first create a dedicated branch and checkout to this (otherwise it would create a so-called "HEAD-detached conflict").

§ Use "git branch -d <branch_name>" to locally delete a branch (then check the result with "git branch"). Keep in mind deleting a branch actually means deleting its branch-label. Moreover, note that the command fails if the branch to be deleted is "dangling" (i.e. it has commits which have not been merged back yet to any 'long-lived' branch). To solve this, you can decide to either merge it back or force its deletion via "git branch -D <branch_name>". To revert an accidental/unintended branch deletion use "git reflog" (showing LR list of recent HEAD commits) to read the commit-ID of the deleted dangling branch to be restored and then use "git checkout -b <branch_name> <commit_id>". Finally, remember that Git periodically checks in background withing the project the presence of dangling commits (i.e. commits not linked to a branch anymore, since the latter has been deleted) and delete (aka "garbage-collect") them automatically. Then, to delete the branch also remotely on RR use "git push origin -d <branch_name>" (where '-d' = '--delete').

§ Note that a new branch keeps inside also the whole previous history of its source branch (this can be checked easily via "git log --oneline").

------------------------------------------------------------

>> 11. MERGING <<

§ Merging allows to combine the work of independent branches (usually from a 'short-lived' branch into a 'long-lived' one). There exist x4 types of merging:
- "fast-forward";
- "merge commit";
- "squash merge";
- "rebase merge".

§ "Fast-forward" (FF) moves directly the source/base branch-label to the tip of the topic-branch and cannot cause conflicts (therefore, it's possible only if no commits have been added to the source/base-branch in the meanwhile). In this case, after merging both branches contain exactly the same commits, thus the base-branch inherits all the topic-branch commits (even if later the topic-branch gets deleted). With FF-merging the resulting commits-history (aka 'commits-graph') is linear, i.e. no commits have multiple parents (this can be checked via "git log --oneline --graph"). Commands to perform an FF-merging:
- after pushing the final changes on the topic-branch (i.e. the "merge-from-branch", aka "active" branch), switch to the base-branch (i.e. the "merge-to-branch", aka "passive" branch) and pull (even if nothing is assumed to have changed) >> "git checkout <base_branch> && git pull" [NB: as said, 'pull' is theoretically not needed in this case since nothing is assumed to have changed in the meanwhile on the base-branch, but nonetheless it's always good practise];
- merge back topic-branch into base-branch (note FF is always the default type of merging attempted by Git at first) >> "git merge <topic_branch>" [NB: whenever using the command "merge", Git specifies the type of merging is trying to execute (e.g. by printing 'Fast-forward' on shell)];
- verify your base-branch is now 'ahead of origin by 1 commit' and push merge-changes to RR >> "git status && git push";
- [check the topic-branch commits have been added to the base-branch, HEAD points now to both branches, and commits-graph is linear >> "git log --oneline --graph"]; 
- [delete the merged topic-branch both locally and remotely (see Section #10) - this is not mandatory, but recommended to save space on both disk and GitHub and keep project versioning cleaner (NB: a merged topic-branch is never deleted automatically by Git, it has to be done explicitly by the user via this command)].

§ Fast-forward example:
A   [base-branch]                         
  \_ B -- C -- D   [topic-branch]
=> FAST-FORWARD =>
A -- B -- C   [base-branch]

§ "Merge-commit" (MC) combines the commits at the tips of the merged branches and places the result into the merge commit. In this case, the merged-commit has always multiple parents. Moreover, MC may cause conflicts if the two branches end up modifying the very same files of the project. The commands to perform an MC merging are the very same as for FF, with the only difference (assuming for the moment no conflicts occur) that when the 'merge'-command is executed Git automatically opens a file (e.g. named "MERGE_MSG") where to write (at the very first line by replacing the default message, if wanted) details/explanations about the merging. Note in this case the final merged-commit contains a combination of both branches, thus you have a non-linear commits-graph (check via "git log --oneline --graph").
Finally, remember it's possible to create an MC even for simpler FF cases by using "git merge --no-ff <topic-branch>". This way, the merged-commit will keep track also of the topic-branch existence (thus, producing a non-linear commits-graph). This solution generates exactly the same project files as FF would, the only difference regards the project-history information. In particular, MC allows a more accurate history-tracking (since topic-branches are not concealed), whereas FF can help to keep the history-tracking cleaner; so usually it's a software team decision which policy to adopt.

§ Merge-commit example:
A -- D -- E   [base-branch]                         
  \_ B -- C   [topic-branch]
=> MERGE-COMMIT =>
A -- D -- E -- M   [base-branch]
  \_ B -- C _/
[i.e. the base-branch commit-history after merging keeps track of also all topic-branch commits (even if topic-branch is later deleted)]

§ "Squash-merge" (SM) merges the topic-branch tip into the base-branch tip (thus, conflict may arise in this case too). This can help keeping the commit history cleaner, but also means the base-branch loses/discards the topic-branch history after merging (see the graphical example below). Therefore, SM is a form of 'history-rewriting'.

§ Procedure for squash-merging:
- checkout to base-branch >> "git checkout <base_branch>";
- apply SM >> "git merge --squash <topic_branch>";
- commit (and then decided wheter to accept or modify the squash message prompted) >> "git commit";
- [remove topic-branch after merging >> "git branch -D <topic-branch>"].

§ Squash-merge example:
A -- C   [base-branch]                         
  \_ B -- D -- E   [topic-branch]
=> SQUASH =>
A -- C -- F   [base-branch]
[i.e. commits B/D/E are lost in the base-branch, since only the already-merged commit F is saved]

§ "Rebase-merge" is treated in Section #15.

§ In case of long-running topic-branches, it's always a good practise to periodically merge back to the source base-branch, in order not to stray too much from the latter and avoid a potential huge number of conflicts in the end.

§ To check the outcome of a merge without automatically generate a commit, use:
- checkout to base-branch >> "git checkout <base_branch>";
- apply conditional merge >> "git merge --no-commit --no-ff <topic_branch>";
- check the terminal outcome message to verifiy if conflicts happened;
- open Git GUI and verify that merged files have been already staged but not committed yet;
- (to revert the whole merge process >> "git merge --abort").

------------------------------------------------------------

>> 12. CONFLICTS <<

§ Conflicts arise when trying to merge branches that have modified the same parts (aka "hunks") within the same files. Thus, in this case the user is asked to make a decision on what to save exactly. Note that no conflicts arise if changes have been made on separate files or even on separate hunks of the same files, since Git usually manages to resolve them autonomously.

§ Procedure to resolve conflicts:
- checkout to base-branch (see Section #11 for more details) >> "git checkout <base_branch>";
- try merging topic-branch into base-branch >> "git merge <topic-branch>";
- at this point, if conflicts have been detected Git, shows a message reporting all the project files inside which there are conflicts that cannot be automatically resolved (e.g. 'CONFLICT: Merge conflict in file xyz.c'), and modifies the content of these files in the WT to highlight the conflicting sections;
- [by checking now the current state of LR branch via "git status", Git should answer 'You have unmerged paths', giving you also the chance to abort the merge attempt via "git merge --abort" (restoring the WT state to the latest LR base-branch commit)];
- to manually resolve the conflicts, open these files one by one with your editor (e.g. Visual Studio Code) and solve the conflicts (i.e. the section of which branch to keep), then save and close them;
- stage the merge-solved files >> e.g. "git add xyz.c";
- commit to LR >> "git commit" (comment is usually not essential in this case) [NB: see details in Section #11 about MC-merging for the text file prompted automatically by Git at this point];
- [by checking now the current state of LR branch via "git status", Git should answer that LR and WT are clean and your base-branch is ahead of origin by 2 commits];
- push changes to RR >> "git push";
- [check via "git log --oneline -- graph" and in GitHub's 'Network graph' the merge has been executed successfully];
- [delete merged topic-branch (see Section #10 and #11)];

§ Git marks files where conflicts occurred while trying to merge as follows:
<<<<<<
... <base-branch>/HEAD code ...
======
... <topic-branch> code ...
>>>>>>

§ To check which project files contain conflicts to be solved after a merge use "git diff --check" (if none or after solving all of them, the command simply returns no message). Plus, they are labeled as "unmerged" as a result of "git status".

------------------------------------------------------------

>> 13. TRACKING-BRANCHES <<

§ "Tracking-branches" are local branches representing remote branches. They are named "<remote>/<branch>" (e.g. "origin/master", where 'origin' is a shortcut for remote repository URL/SSH address). Just after cloning a repository, the remote 'master' branch on GitHub and the local tracking-branch 'origin/master' are actually synchronized (i.e. containing the very same commits). However, remember tracking-branches shall be then updated explicitly by the user to keep the synchronization! For instance, if after cloning the repository another user pushes a new commit on the same branch, RR becomes 1 commit ahead of your LR (aka "decoupled"), but you cannot know this locally (via "git status") until you perform a 'fetch/pull' command (since your 'origin/master' tracking-branch still points to the previous commit). The opposite example is when you create a new commit locally (e.g. on branch 'master') which has not been pushed yet to RR, where executing "git status" returns 'Your branch is ahead of 'origin/master' by 1 commit'.

§ By default the command "git branch" shows only the LR branches. Instead, "git branch --all" shows also all tracking-branches (representing remote branches), which are all unique branches except for 'remotes/origin/HEAD' (by default 'remotes/origin/HEAD -> origin/master'). The latter is actually a symbolic reference specifying the default remote tracking-branch and allows to only type '<remote>' instead of the whole '<remote>/<branch>' in Git commands (e.g. 'origin' instead of 'origin/master') in Git commands [NOT ESSENTIAL].

§ Useful commands related to tracking-branches:
- to show commit-history of a remote branch (again, tracked only indirectly via the corresponding tracking-branch) >> "git log origin/master [--oneline]" (equivalent to simply "git log origin [--oneline]" if 'master' is set as default remote tracking-branch);
- to change locally the default remote tracking-branch (e.g. to 'develop', since that's usually the one where the bulk of the work is done by the team) >> "git remote set-head <remote> <branch>" (e.g. "git remote set-head origin develop", so from now on "git log origin [--oneline]" will refer to 'develop' commits and "git branch --all" will show 'remotes/origin/HEAD -> origin/develop');

§ The initial default tracking-branch (e.g. corresponding to the default branch while cloning) can be changed for all users through "github website > settings > general > default branch". Note this is always set by default to 'master' for new repositories.

§ As already said above, the "git status" and "git log --oneline --graph --all" commands include info about tracking-brances status and inform you if the local branch and the corresponding tracking-branch are out of synch or not (e.g. 'Your branch is up-to-date with origin/master'). 

------------------------------------------------------------

>> 14. FETCH, PULL & PUSH COMMANDS <<

§ Most Git commands interacts with LR only, but there are also x4 main "network-commands" in charge of communicating with the RR:
- "clone" >> to copy a remote repository locally;
- "fetch" >> to retrieve locally new objects and references from RR;
- "pull" >> to fetch and merge commits locally;
- "push" >> to add new object and reference to RR.

§ The "fetch" command allows to update local tracking-branches with info from RR without merging changes/updates immediately into WT, thus does not affect you LR labels and just makes the user aware of the actual/current RR state (see Section #13). In case LR is already up-to-date with RR, no info is displayed on shell after executing the command. Plus, executing "git status" before and after a "git fetch" command allows to understand if and how LR and RR are out of sync (and gives also suggestions, e.g. if branch can be fast-forwarded on not in case RR is ahead by some commits). This command is also essential/recommended to get aware of and retrieve info about new branches pushed remotely by other users.

§ The "pull" command combines "git fetch" and "git merge FETCH_HEAD". If any object is fetched, the tracking-branch is merged into LR/WT. Thus, it may create conflicts. Hereafter some useful merge-options for the "pull" command are listed:
- "--ff" >> fast-forward if possible, otherwise perform a merge-commit (default);
- "--no-ff" >> always include a merge-commit (formal);
- "--ff-only" >> cancel instead of doing a merge-commit (abort if fast-forward not possible);
- "--rebase [--preserve-merges]" >> (see Section #15).

§ There can be multiple situations when executing "git pull":
- LR and RR in sync, without WT unstanged/uncommitted/unpushed changes >> no effect;
- LR and RR in sync, with WT unstanged/uncommitted/unpushed changes >> no effect;
- LR ahead of RR, without WT unstanged/uncommitted/unpushed changes >> no effect;
- LR ahead of RR, with WT unstanged/uncommitted/unpushed changes >> no effect;
- RR ahead of LR, without WT unstanged/uncommitted/unpushed changes >> fast-forward pull update (no conflicts);
- RR ahead of LR, with WT unstanged/uncommitted changes not conflicting with latest RR commits >> fast-forward pull update (no conflicts) with previous WT unstanged/uncommitted changes preserved;
- RR ahead of LR, with WT unstanged/uncommitted changes conflicting with latest RR commits >> pull aborted [see 'PULL MESSAGE #1'];
- RR ahead of LR, with LR unpushed commits having no conflicts with latest RR commits >> merge-commit (no conflicts) [see 'PULL MESSAGE #2'] - i.e. in this case it's created a new local commit which is the automatic combination of the latest RR commit and the unpushed LR commit (plus, a message is prompted asking the user to provide a comment for the merge), a checking now the local state via "git status" inform you that LR is ahead of 'origin/master' by 2 commits (i.e. pull-merge is just local for the moment) - note this case has many similarities with the topic-to-base-branch merging already discussed in Section #11;
- RR ahead of LR, with LR unpushed commits having conflicts with latest RR commits >> merge conflict to solve [see 'PULL MESSAGE #3'] - in this case you Git automatically marks the issues on the conflicting files (e.g. 'xyz.c') as already reported in Section #11, waiting for the user to manually resolve them (then 'add' + 'commit' = 'Your branch is ahead of 'origin/master' by 2 commits' + 'push' = merge-branch created in RR as if you created a topic-branch to solve the conflict) or abort the pull/merge ("git merge --abort");
- [NB: always try to avoid the last situations listed above (i.e. generating merge-conflicts) and perform "git pull" with WT clean and no unpushed commits on LR (i.e. create a new topic-branch whenever a bugfix/feature-addition is needed, do not work directly on the base-branch)].

§ PULL MESSAGE #1 - Pull aborting:
"Updating b7b6353..bbb97e7
error: Your local changes to the following files would be overwritten by merge:
	xyz.c
Please, commit your changes or stash them before you can merge.
Aborting"

§ PULL MESSAGE #2 - Pull merge-commit:
"remote: Enumerating objects: 5, done.
remote: Counting objects: 100% (5/5), done.
remote: Compressing objects: 100% (1/1), done.
remote: Total 3 (delta 2), reused 3 (delta 2), pack-reused 0
Unpacking objects: 100% (3/3), done.
From https://github.com/AlectoSaeglopur/proj_16
   4f83692..badcf67  master     -> origin/master
Merge made by the 'recursive' strategy.
 xyz.c | 1 +
 1 file changed, 1 insertion(+)"

§ PULL MESSAGE #3 - Pull merge-conflict:
"Auto-merging mas1.txt
CONFLICT (content): Merge conflict in xyz.c
Automatic merge failed; fix conflicts and then commit the result."

§ The "push" command allows to add/forward current branch commits from LR to RR. Its basic syntax is "git push [-u|--set-upstream] [<repository>] [<branch>]" (see Section #6 for more details). Keep in mind it's always good practise to fetch/pull before pushing in order to be aware of the most recent RR state for that branch. In fact, trying to push when RR is ahead of LR by some commits fails (NB: that's why the work on a single topic-branch should be done by one user only at a time for simplicity's sake) returning the following error:
"! [rejected]   master -> master (fetch first)
'error: failed to push some refs to origin'
..."

§ Remember to always execute "git status" after each "git pull", in order to check the updated state of the repo. This especially usefull in case the project contains submodules to check if any of them requires an update; in case run "git submodule update --recursive" (see Section #20).

------------------------------------------------------------

>> 15. REBASING & REWRITING HISTORY <<

§ "Rebasing" means moving commits to a new parent, i.e. the unique commits of a topic-branch are reapplied to the tip of the base-branch. Since ancestor chain has changed, each of the reapplied commits has now a different commit ID. An advantage is that after rebasing the merging from topic-branch to base-branch can be fast-forward (and not merge-commit), thus easier.
Remember that Git actually works by estimating and versioning only the differences between consecutive commits (known as "diff" or "patch"). Rebasing means reapplying the 'diffs' to the new parent commits (process called "reapplying commits"). Of course, since reapplying commits is a form of merging, that's susceptible to merge-conflicts (e.g. if commits 'B' and 'D' modify the same sections of the same files, considering the rebasing example hereafter).
Rebase has both pros and cons:
+ allows to incorporate changes from parent branch;
+ avoids "unnecessary" commits (cleaner history);
- merge-conflicts may arise;
- severe issues if commits are shared with other users;
- does not preserve the actual commits sequence (less accurate history).

§ Rebasing example:
A -- D   [base-branch]                         
  \_ (diffAB) -- B -- C   [topic-branch]
=> REBASING =>
A -- D -- (diffAB) -- B' -(diffBC)- C'   [base-branch]

§ CAUTION: do not rewrite history that's shared with other users!

§ There are x2 types of rebasing:
- "regular rebase", i.e. the one discussed so far;
- "interactive rebase", to rebase (by adding the "-i" option) a series of commits belonging to a specific branch - here commits can be edited, stopped, dropped/deleted, squashed (i.e. combining a specific commit with the previous one into a new single commit, combining also messages), fixed-up (just like squash, but discarding the comment of the newer commit), reordered, etc.

§ Useful commands for regular-rebasing:
- to checkout topic-branch parent to upstream/base-branch >> "git rebase <upstream> <branch>" (e.g. "git rebase develop bugfix_358") [NB: equivalent to "git checkout <topic-branch> && git rebase <upstream>"].
- in case of conflict, you can either solve them (check conflicting files by "git status", manually resolve conflicts as usual through editor, stage changes via "git add <resolved_files>" and complete rebase via "git rebase --continue") or abort it (via "git rebase --abort"). 

§ Useful commands for interactive-rebasing:
- to list current branch commits (after the specified one) in an editor in order to be modified (e.g. the two most recent commits B and C can be combined into B') >> "git rebase -i <after-this-commit>" [NB: for more details refer to Coursera lesson #16].

§ Git gives the possibility to modify/adjust the most recent commit (files, comment, etc) through the "amend" command. This also modifies the commit ID associated to that commit, thus rewrites history. Use the procedure hereafter to amend the most recent commit:
- add/modify/remove some files within the working tree (if needed)...;
- stage changes >> "git add <amended_files>"
- amend commit >> "git commit --amend -m "new_comment"" or "git commit --amend --no-edit" (not to modify the original message);

------------------------------------------------------------

>> 16. PULL-REQUEST <<

§ "Pull-request" is a feature provided by most Git hosting services/sites (such as GitHub or BitBucket). Its ultimate goal is again to merge a topic-branch into a base-branch, but improving team communication related to the topic-branch work as well (e.g. team members can send notifications to each others, leave comments/feedbacks, review code and approval/decline its content for merging). Note since pull-request is a feature provided basically by the hosting services (as already said), it's not possible to handle this directly via Git bash.

§ Pull-requests can be actually opened at any time of the topic-branch life:
- at the very beginning to allow topic-branch creation;
- whenever comments/feedbacks on the current progress of the topic-branch is needed;
- when branch is ready to be reviewed and merged back.

§ There exist x2 pull-request cases depending on the repositories configuration:
- "single repository" (SR), where topic-branch merges back to base-branch of the same repository (i.e. the usual case, with only x1 RR is involved);
- "multi-repository" (MR), where 'fork-repository' merges back to 'upstream-repository' (i.e. x2 RRs are involved).

§ Procedure for SR-pull-request:
- create and checkout to new topic-branch >> "git branch <topic_branch> && git checkout <topic_branch>";
- add/modify/remove some files within the working tree...;
- stage changes >> "git add --all";
- commit to LR >> git commit -m "comment";
- push commit to RR >> "git push -u origin <topic_branch>";
- open GitHub website and go to "PROJECT > Pull requests > New pull request";
- here select the merging direction for branches (i.e. 'master <- bugfix_352') and click "Create pull request" (plus, here you can also select the desired merging strategy, e.g. merge-commit, squash, etc);
- then on the right-side of the webpage you can add other team members as reviewers;
- [in case there are conflicts, you can solve them directly on GitHub website on the same 'Pull requests' page and then click "Merge commit"];
- now wait for other members to review/approve;
+ on the other hand, the reviewer has to open the same "Pull requests" page on GitHub, click on "Add your review", and decide whether to comment/approve/request-changes and click "Submit";
- then any team member can click "Merge pull request > Confirm merge" to complete the merging procedure (pull request is then automatically closed);
- finally all users shall checkout to the base-branch and execute "git pull" to retrieve the latest commit locally.

§ MR-pull-requests involve a 'fork-repository' merging back to its 'upstream-repository', and can be done either via GitHub website or Git bash (see more details in Section #17).

§ Note if you open a pull-request to merge a topic-branch into a base-branch without checking for conflicts before, this may cause the pull-request to be opened and approved twice. In fact, after approving the 1st pull-request the actual merging is executed remotely, then if conflicts are detected the user is asked to solve them and open another pull-request to get the conflicts-resolution approved too. Thus, it's always good practise to avoid conflicts on pull-requests. Hereafter the procedure to handle topic-branch-to-base-branch merge-conflicts locally before opening pull-request (so that pull-request on GitHub will be surely conflicts-free):
- checkout and pull on base-branch (e.g. 'develop') >> "git checkout develop && git pull";
- create and checkout to new topic-brach (e.g. 'xyz') >> "git checkout -b xyz";
- make changes on WT for topic-branch...
- add, commit and push changes >> "git add --all && git commit -m "<comment> && git push [-u origin xyz]";
- checkout and pull again on base-branch (assuming other team members pushed other commits in the meanwhile) >> "git checkout develop && git pull";
- checkout to topic-branch >> "git checkout xyz";
- merge base-branch into topic-branch locally (so to update with latest changes) >> "git merge develop";
- resolve conflicts locally (if any);
- add, commit and push merge-update/conflicts-solving >> "git add -A && git commit -m "<comment> && git push";
- open pull request on GitHub from topic-branch to base-branch (e.g. "develop <- vkn").

------------------------------------------------------------

>> 17. FORKING <<

§ "Forking" means copying an existing remote repository to your own GitHub account, ending up to create a second remote repository (besides the original one, which is usually referred to as the 'source of truth'). Forking workflows is common for open-source projects, so that topic-branches do not need to be shared (thus, for example, rebasing is way easier). However, you shall always pay attention to manually keep the upstream and fork repositories in sync to avoid issues (since this is not handled automatically by Git).

§ A fork can be used for several reasons:
- make experiments with or learn from the upstream repository without affecting its official workflow;
- work independently on the same project and issue pull-requests only for merging back to the upstream repository;
- switch to a different source of truth for the project.

§ Useful commands for forking:
- to create a new fork, go to 'github website > PROJECT > Fork this repo';
- to synchronize a fork with the latest upstream repo commits, go to 'github website > PROJECT > Sync no' (NB: this creates a merge-commit on the fork repo, then update the LR via "git pull").

------------------------------------------------------------

>> 18. WORKFLOWS <<

§ "Gitflow" is the standard/official versioning workflow that allows safe and continuous releases of the project. For example, the project versioning should include:
- two main base-branches, such as 'master' (whose tagged commits contain firmware versions to release to customers) and 'develop';
- any number of topic-branches for each new task to fulfill (hotfix_XYZ/bugfix_XYZ/feature_XYZ/release_XYZ)
- [for more details see '19_git_workflows.mp4' from 3:30 on].

§ Some Gitflow recommendations:
- perform only merge-commits on 'master' branch;
- commit to 'master' branch only from 'release' or 'hotfix' branches;
- after committing to 'master' branch, merge the same changes into 'develop' branch too (in order not to lose track of updates/patches applied during release/hotfix phase);
- no direct work shall be done on 'master'.

------------------------------------------------------------

>> 19. STASH <<

§ The "git stash" commands allow to take WT uncommitted changes (both staged and unstaged), save them away for later use, and then restore them to WT:
- to stash uncommitted changes away >> "git stash" (equivalent to "git stash push") [NB: after this command, execute "git status" and check WT is now clean];
- to restore latest stashed changes to WT and remove them from stashing-area >> "git stash pop" [NB: 'latest changes' means the stash-entry labeled as 'stash@{0}'];
- to restore latest stashed changes to WT but keep them in stashing-area (for example, this is useful if you need to apply the same stashed changes to multiple branches) >> "git stash apply".

§ Note that by default the "git stash" command stores:
- staged changes (i.e. changes that have been added to your index);
- unstaged changes (i.e. changes made to files that are currently tracked by Git);
...but does not store:
- new files in WT that have not been staged yet (i.e. not part of the versioning yet) >> add the "-u" (where "-u" = "--include-untracked") option to include new untracked files (e.g. "git stash -u");
- ignored files (i.e. part of the '.gitignore' file) >> add the "-a" (where "-a" = "--all") option to include changes to ignored files as well (e.g. "git stash -a").

§ The user is not limited to a single stash at a time, but can run "git stash" multiple times to create multiple stashes in sequence. By default, stashes are identified simply as a 'WIP' (aka "Work In Progress") on top of the branch/commit you created the stash from. Then "git stash list" can be used to list all stashed currently stored. However, after a while it can be difficult to remember what each stash contains (since, for example, they are all listed as something like "stash@{0}: WIP on master: 2e16987" or "stash@{4}: WIP on develop: f955ab0"). To provide a clearer and more detailed tracking, it's recommended to include a stash description via the "save "message"" option (e.g. "git stash save "stashed changes on xyz.c" [-u]").

§ To restore older changes use include the desired stash entry as additional argument (e.g. "git stash pop stash@{2}" or "git stash apply stash@{3}").

§ To retrieve info about a specific stash, use "git stash show stash@{n}" and add the "-p" option to display also all differences within modified files (e.g. "git stash show -p stash@{1}").

§ Use "git stash drop stash@{n}" to delete a specific stash, or "git stash clear" to delete all of them.

§ Of course, restoring stashed changes via "pop/apply" can generate conflicts if in the meanwhile the same sections of the same files have been modified. In this case, just resolve manually the conflicts on each file and then stage the changes as usual.

§ Remember stashes are actually encoded locally as commit objects. The special ref at ".git/refs/stash" points to the most recent stash, and previous stashes are referenced by the stash ref's reflog. This is why you refer to stashes by stash@{n}, since you're actually referring to the n-th reflog entry for the stash ref.

------------------------------------------------------------

>> 20. SUBMODULES <<

§ Git submodules allow you to keep a Git repository as a subdirectory of another Git repository. Submodules are simply a reference to another repository at a particular snapshot in time, and enable a Git repository to incorporate and track version history of external code.

§ A Git submodule is a record within a host Git repository that points to a specific commit in another external repository. Submodules are very static and only track specific commits. Submodules do not track Git refs or branches and are not automatically updated when the host repository is updated. When adding a submodule to a repository a new ".gitmodules" file will be created. The ".gitmodules" file contains meta-data about the mapping between the submodule project's URL and local directory. If the parent repository has multiple submodules, the ".gitmodules" file has an entry for each submodule.

§ Using submodules is especially useful:
- when an external component or subproject is changing too fast or upcoming changes will break the API, you can lock the code to a specific commit for your own safety;
- when you have a component that is not updated very often and you want to track it as a vendor dependency;
- when you are delegating a piece of the project to a third party and you want to integrate their work at a specific time or release (assuming updates are not too frequent);
- in general, to increase projects modularity and reusability.

§ Useful commands for submodules:
- to add a new submodule to an existing/main repository >> "git submodule add <url>" (then new submodule files have to be staged/committed/pushed in order to become a steady part of the main project) [NB: after pushing to RR, open GitHub website and check the submodule commit-reference (e.g. "@3e5a7c") has been added to the main project];
- after cloning a remote repository containing submodules, remember these have to be also manually initialized (otherwise, submodule folders would remain empty) >> "git clone <url> && git submodule update --init --recursive";
- to import/update submodule changes on parent project >> "git submodule update --recursive [--remote]" (see more details below);
- to apply a standard Git command on all submodules of the parent project >> "git submodule foreach --recursive <command>" (e.g. "git submodule foreach --recursive git reset --hard" or "git submodule foreach --recursive git clean -dxf").

§ Once submodules are properly initialized and updated within a parent repository they can be utilized exactly like stand-alone repositories. This means that submodules have their own branches and history. When making changes to a submodule it is important to push submodule changes and then update the parent repositories reference to the submodule.

§ Remember that changes on submodules cannot be made directly from the parent repository (since they cannot be staged/committed from the parent repo). To make changes on a submodule, just clone it locally as a standalone project and work on that as for any other repository (i.e. creating topic-branches, merging-back to base-branch, etc.). Then, to import submodule changes on the parent project:
- apply submodule changes from RR to WT >> "git submodule update --recursive --remote" [NB: this command actually updates all submodules used inside the parent project, not just one];
- alternatively, submodules can be updated one by one by opening a bash inside each of their subfolders and executing "git fetch/pull" [NB: instead executing "git fetch/pull" at parent project level is not able to detect submodules updates from RR];
- then stash, commit and push changes to update submodules references within the parent project >> "git add --all && git commit -m "submodules updated" && git push".

§ To locally update a submodule whose remote path has been changed lately:
- delete the related folder within LR's "source" folder;
- delete the related folder within LR's ".git" folder;
- open Git bash inside project main path and type "git submodule sync && git submodule update --recursive";
+ alternatively, you could simply delete the entire LR and clone it again from scratch.

------------------------------------------------------------

>> 21. REVERT, RESET, RESTORE & CLEAN <<

§ In Git a 'reset'-operation undoes one or multiple commits and reverts back to a previous state of a project by removing all subsequent commits (literally resets current HEAD to the specified state). Instead, a 'revert'-operation takes the specified commit, inverse the changes from that commit, and creates a new revert-commit. The ref pointers are then updated to point at the new revert commit making it the tip of the branch.

§ 'Reverting' has two important advantages over 'resetting':
- it does not change the project history (therefore safer for commits that have already been published to a shared repository);
- it is able to target an individual commit at an arbitrary point in the history, whereas "git reset" can only work backward from the current commit and delete latest commits until the desired one;
- unlike 'reset', 'revert' can be used on public history.

§ Useful 'revert' commands:
- to revert a branch to some previous commit >> "git revert <older_commit_id_to_revert>" (e.g. "git revert HEAD" to create a new commit reverting the very last commit only, i.e. restoring the second-to-last commit).

§ Useful 'reset' commands:
- to unstage specific files/directories (i.e. undo "git add" commands) within current branch >> "git reset <file/directory>" (e.g. "git reset xyz.c");
- to unstage all files/directories within current branch >> "git reset";
- to unstage all files/directories and also reset WT to latest commit state (i.e. cancel all staged and unstaged changes) >> "git reset --hard";
- to locally delete latest commits, move back to a previous specified commit and reset WT to that previous commit state (i.e. all deleted-commits changes get lost) >> "git reset --hard <commit_id>";
- to locally delete latest commits, move back to a previous specified commit but preserving all deleted-commits changes inside staging area >> "git reset --soft <commit_id>";
- to locally delete latest commits, move back to a previous specified commit but preserving all deleted-commits changes inside WT >> "git reset <commit_id>".

§ The 'restore' command allows to undo/remove unstaged changes within the WT. Useful 'restore' commands:
- to revert all WT unstaged changes (i.e. move back WT to latest commit) >> "git restore .";
- to revert WT unstaged changes on specific files/directories (i.e. move back WT to latest commit) >> "git restore <file/directory>" (e.g. "git restore xyz.c").

§ The clean command allows to undo/remove untracked changes within the WT. Useful 'clean' commands:
- to just display untracked files that could be removed from WT, include the "-n" flag >> "git clean -n" or "git clean -n src/";
- to apply the command recursively on subdirectories, include the "-d" flag >> "git clean -d <path>" or "git clean -nd";
- to force the removal of ignored files as well (i.e. still present locally within WT but no more part of the versioning), include the "-x" flag >> "git clean -nx" or "git clean -nx <path>";
- to actually remove untracked/ignored files/directories from WT, include the "-f" flag (where "-f" = "--force") >> "git clean -f <file/directory>" or "git clean -dxf" (most general, i.e. applied on the whole repo);
- to use the command in interactive mode (i.e. decide actions file by file), include the "-i" option >> "git clean -i".

------------------------------------------------------------

>> 22. VARIOUS <<

§ Useful Linux commands:
- "ls -a" to show all files and directories within current folder (including hidden ones);
- "clear" to clear shell/bash.

§ Additional useful Git commands:
- to get an overview of the most common commands >> "git help";
- to get info about a specific command >> "git help [command]" or "git [command] -h" (e.g. git status -h");
- to check current Git version installed >> "git --version";
- to open Git GUI >> "git gui" (NB: add "&" to open GUI and still be able to write commands on bash, i.e. "git gui&");
- to display info about RR (associated to your LR) >> "git remote -v" (where "-v" = "--verbose"); 
- to display differences inside project files between WT and index (i.e. unstaged changes) >> "git diff [--word-diff]" (or via Git GUI);
- to display differences inside project files between staging area and LR (i.e. uncommitted changes) >> "git diff --cached [--word-diff]";
- to display differences inside project files between LR and RR (i.e. unpushed changes) >> "git diff <remote>/<branch> [--word-diff]" (e.g. "git diff origin/develop --word-diff");
- to checkout to another branch discarding all current unstanged WT changes >> "git checkout -f <branch>";
- to display graphical commit-history of current branch >> "git log [--oneline] --graph";
- to display commit-history of current branch including differences (i.e. files changes) >> "git log --diff [--oneline] [--graph]";
- to display commit-history of all refs (stored in "refs/", i.e. of all branches plus stashes) >> "git log --all [--oneline] [--graph] [--diff]";
- to show what commit and author last modified each line of a specific file >> "git blame [-L 2,5] [-w] <path>/<file>" ("-L" to specify the lines-range to check inside the file, and "-w" to ignore whitespace changes);
- to set a Git command alias >> "git config --global alias.<custom_name> '<command_expression>'" (e.g. "git config --global alias.nwbr 'checkout -b'", thus from now on "git nwbr <branch_name>" is equivalent to "git checkout -b <branch_name>");
- to list all existing Git command aliases >> "git config --get-regexp ^alias";
- to delete an existing Git command alias >> "git config --global --unset alias.<custom_name>" ("git config --global --unset alias.nwbr");
- to solve the 'HEAD detached' issue on current LR branch, just checkout to another branch and then back again to the original one (this always resets 'HEAD' to the latest commit).

§ Git wildcards:
- you can add an additional path to commands in order to apply actions only on a specific LR subfolder >> e.g. "git status src/" or "git add settings/";
- you can apply commands only on files with a specified extension >> e.g. "git status \src/*.c" (to check the status of all '.c' files within 'src' subfolder) or "git add \*.c \*.h" (to only stage changes of all '.c' and '.h' files within the repo);
- to match a specific file pattern with any path inside LR >> "git add **/xyz.c" (to stage changes on one or multiple files named 'xyz.c' in any position within the repo) or "git add **/xyz.*" (to stage changes on all files named 'xyz.' with any extension in any position within the repo, e.g. useful to include at same both '.h' and '.c' files of the same module);
- for more details about pattern-matching and wildcards see "ignore_wildcard_patterns.pdf".

§ GitHub tips:
- to change repository visibility (public/private), transfer repository ownership or delete repository, go to "github website > PROJECT > settings > (scroll down) > danger zone";
- the versioning 'graph-view' (see "github website > insights > network") is enabled only for paid versions (e.g. 'Enterprise') or if the repository is kept public;
- to add branch protection rules, go to "github website > settings > branches >> add branch protection rule" >> for example, set 'Branch name pattern' to 'master', tick 'Require a pull-request before merging' and below 'Require approvals', set 'Required number of approvals' (e.g. x1), and finally tick 'Do not allow bypassing the above settings';
§ to give access to a repository you own to another team member (so that he/she can gain pull/push rights on that), the latter be set as "collaborator" of the project (note this shall be repeated also for all submodules included in the parent repo) >> go to "github website > PROJECT > settings > collaborators > add people", then he/she shall accept the invitation received on GitHub website [NB: Keep in mind that if the repository is set as "public" by the owner, this makes it visible and clonable by any GitHub user; however only if users added as collaborators can also push. Otherwise, if the owner sets the repository as private, the only way for another user to clone/push is to be included as a collaborator of the project];
§ Regarding the different kinds of topic-branches that you can create on GitHub:
- "feature-branch", implementing new features (e.g. adding Bluetooth connectivity to the project);
- "bugfix-branch", fixing a bug during firmware development/testing;
- "hotfix-branch", fixing a bug on firmware version already release on the market.

§ Extra tips:
- Git always provides hints as a response for each command, read and follow them carefully;
- see "https://git-scm.com/docs/" and "https://www.atlassian.com/git/tutorials" for additional documentation about Git.
