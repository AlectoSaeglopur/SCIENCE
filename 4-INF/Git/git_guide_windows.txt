
>> 1. INSTALLATION <<

§ Installation procedure:
- launch Git.exe installer;
- use "C:\Program Files\Git" as installation path;
- tick "Open Git Bash here" and untick "Open Git GUI here" within "Windows Explorer integration";
- select "Use Visual Studio Code as Git's default editor";
- select "Let Git decide" about default branch naming;
- select "Git from command line and also from 3rd-party software";
- select "Use bundled OpenSSH";
- select "Use the OpenSSL library";
- select "Checkout Windows-style, commit Unix-style line endings";
- select "Use MinTTY";
- select "Fast-forward or merge" as pull-command behavior;
- select "Git Credential Manager";
- tick "Enable file system caching";
- skip the "experimental option" and start the installation.

------------------------------------------------------------

>> 2. SETUP <<

§ Configure user's name and email:
- configure Git username >> "git config --global user.name "filippo valmori"";
- configure Git email >> "git config --global user.email "filippo.valmori@libero.com"";
- [for the last x2 commands, "--system" or "--local" could be used in place of "--global" (however that's unusual, see Coursera's training for more details);
- readback set user's name and email >> "git config user.name" and "git config user.email";

§ To generate SSH key (using ED25519 algorithm) for encrypting/authenticating communication from/to server:
- open Git bash (anywhere);
- type "ssh-keygen -t ed25519 -C "your_email@example.com"" specifying your email;
- empty-ENTER until completion;
- check public (.pub) and private keys have been successfully created in the specified (hidden) folder ".ssh" (e.g. "C:\Users\Filippo\.ssh\");
- from internet browser, go to "github website > profile icon > settings/manage-account > ssh keys" and upload the authentication public-key just created (simply drag-and-drop it);
- as a confirmation, type on bash "git gui" to open Git GUI and here go to "help > show ssh key" and verify the key has been successfully loaded.
- NB: setting up the SSH key is helpful because it allows to automatically authenticate yourself when accessing the remote server, thus without the need of supplying your username and password at each visit. For further details see here "https://confluence.atlassian.com/bitbucketserverkb/ssh-rsa-key-rejected-with-message-no-mutual-signature-algorithm-1026057701.html".

------------------------------------------------------------

>> 3. LOCATIONS & SYNTAX <<

§ Locally on each developer's PC the so-called "project directory" folder contains:
- "working tree" (WT), where the actual project files and directories (relative to a single commit at each time) are placed and can be edited;
- "staging area" (SA, sometimes called also "index"), where the file planned to be part of the next commit are stored (or "staged");
- "local repository" (LR), storing all the commits of the project (thus, representing its version history).

§ Note that locally SA and LR are located inside the hidden sub-directory "/.git" (thus, removing this folder means removing all the project version history locally).

§ The "remote repository" (RR), unlike the other x3, is located remotely in a single data-center/cloud and represents the common interaction point among all developers (thus it identifies the official state of the project at any time). When LR and RR are synchronized, they contain exactly the same commits.

§ The general syntax for commands is "git [command] [--flags] [arguments]".
More in detail, "git command (-f|--flag) [<id>] [--] [<paths> ...]", where:
- '|' = or;
- '[optional]' = optional values;
- '-f' or '--flag' = command flag;
- '<placeholder>' = required value;
- '()' = grouping for clarity or disambiguation;
- '--' = to disambiguate the command;
- '...' = multiple occurrences possible.

------------------------------------------------------------

>> 4. CREATE NEW LOCAL REPOSITORY <<

- if the project does not exist yet in RR, create a folder where to place all repositories (e.g. "repos_folder");
- inside the aforementioned folder, create a sub-folder for the new project to be created (e.g. "proj_1");
- here (e.g. \repos_folder\proj_1\) open a bash and initialize the LR >> "git init";
- check the ".git/" hidden folder has been successfully >> "ls -a";
- add/modify some files within the working tree...

------------------------------------------------------------

>> 5. COMMIT TO LOCAL REPOSITORY <<

- check if there are files/directories modified or untracked in respect of the last commit >> "git status [-s]";
- add desired untracked or modified files/directories (and in turn all files inside the latter) to SA >> "git add [files-or-directories];
- NB: for new repositories it's good practise to add a "README.md" file to the project to the main page (if not existing yet);
- alternatively, add all untracked or modified files/directories to SA without specifying them one by one >> "git add .";
- move all staged files/directories from SA to LR, thus adding a new snapshot/node (representing the current state of the project) to the version history >> "git commit -m "<comment>"";
- verify WT and SA are now clean (at least of all committed files/directories) >> "git status";
- see the overall LR commit-history >> "git log [--oneline] [-X]" (e.g. X=2 can be used to show only the x2 most recent commits);
- NB: not all modified/untracked files in the WT have to be staged and then part of the next commit/push. Typical examples are the .o/.map/.bin/.srec/.exe files generated after building, since only source files (.c/.h) are actually included in the versioning (assuming not to include them into the ".gitignore" file).

------------------------------------------------------------

>> 6. PUSH TO REMOTE REPOSITORY <<

§ In case LR exists (see sections .4 and .5) and RR does not yet:
- open an internet browser and create a new empty repository on GitHub website with the same name of that in your LR (e.g. "proj_1");
- open bash inside LR and link it to RR through its URL/SSH address (e.g. "github website > proj_1 > code > HTTPS/SSH") >> "git remote add <name> <url>" (e.g. <name> = 'origin' or 'proj_1', <url> = "https://github.com/AlectoSaeglopur/proj_1" or "git@github.com:AlectoSaeglopur/proj_1.git", i.e. "git remote add origin git@github.com:AlectoSaeglopur/proj_1.git");
- NB: using SSH addresses is always recommended if SSH key has been already generated and linked for the user (see section .2);
- initialize RR according to current LR state >> "git push -u|--set-upstream <repo_name> <branch>" (e.g. "git push -u origin master", or more specifically "git push --set-upstream proj_1 master").

§ In case RR already exists and LR does not yet:
- clone RR to LR >> "git clone <url>" [again, SSH addresses are recommended (use HTTPS only if SSH does not work)];
- add/modify some files within the working tree...;
- commit desired changes to LR (see section .5, e.g "git add . && git commit -m "<comment>"";
- push current LR state to RR >> "git push".

------------------------------------------------------------

>> 7. OBJECTS & IDS <<

§ Git provides x4 main types of objects:
- commit, i.e. small text file;
- annotated tag, i.e. permanent reference to a commit;
- tree, i.e directories/filenames in the project;
- blob, content of a file in the project.
Typically the user has to care only about commits and annotated tags, whereas trees and blobs are handled internally and hiddenly by Git itself).

§ The name of a Git object is called "ID", consisting of a 40-character hexadecimal string (aka "hash" or "checksum") generated through the SHA-1 encryption algorithm (e.g. the IDs of all commits related to a branch can be seen via "git log"). Often IDs are shortened to first x7 characters to be more user-friendly (e.g. with "git log --oneline").

§ For each commit Git automatically create and associates a unique ID (aka hash). ->> based on avalanche algorithm/principle >> EXPLAIN @todo

------------------------------------------------------------

>> 8. REFERENCES & TAGS <<

§ A commit can be associated with a "reference", i.e. a user-friendly name (e.g. 'HEAD' or 'master') pointing to a commit hash (e.g. '64a0c1...') or another reference (aka "symbolic reference" in this latter case). Therefore, references can be used instead of hashes for simplicity's sake.

§ Each branch has a so-called "branch label", a reference with the same name of the branch (e.g. 'development' or 'master') pointing always to the most recent commit of that branch (aka "tip of the branch"). Note that 'master' is the default name of the main branch in every repository (thus also the 'master'-reference exists for any repository).

§ All references are automatically stored/updated in "./git/refs/heads/" and they are nothing but files named as their names and containing inside the corresponding hash value. The only exception is 'HEAD', which is kept in "./git".

§ The 'HEAD'-reference points to the branch-commit pair currently present in the WT (thus, it can exist only one 'HEAD' per repository). By default it's usually equal to the "label branch" (e.g. 'master' or 'development'), but unlike the latter this can be also moved back to previous commits of the branch using the "git checkout <commit-id>". For example, assuming to be in the 'master' branch, if using "git log --oneline" returns that 'HEAD' points to 'master' (i.e. 'HEAD->master'), then using "git checkout HEAD~" (i.e. "git checkout PREVIOUS_COMMIT_HASH") moves 'HEAD' one commit back and updates the WT accordingly (thus now 'master' becomes one commit ahead of 'HEAD'). Executing now "git checkout master" (i.e. in general "git checkout <branch-name>") resets 'HEAD' equal to 'master' (i.e. latest commit of branch).

§ The '~' and '^' characters can be used to refer to previous commits. In particular, '~' allows to refer to parent commits (i.e. in case of a single parent), whereas '^' to refer to parent in a merge-commit (i.e. in case of multiple parents). For example:
- show latest x4 commits of current branch (e.g. 'master') >> "git log --online -4";
- print detailed info about last commit (assuming 'HEAD->master') >> "git show HEAD" [NB: expected to return the same commit shown as 1st entry by the aforementioned "git log ..."];
- print detailed info about second-last commit >> "git show HEAD~1" or "git show HEAD~" [NB: expected to return the same commit shown as 2nd entry by the aforementioned "git log ..."];
- print detailed info about third-last commit >> "git show HEAD~2" or "git show HEAD~~" [NB: expected to return the same commit shown as 3rd entry by the aforementioned "git log ..."];
- ...

§ "Tags" are references attached to specific commits, acting as a sort of user-friendly labels for these commits. Thus, tags can be used instead of 'branch labels' or IDs for Git commands (e.g. "git show TAG_NAME"). There are x2 types of tags:
- 'lightweight', a simple reference to the commit (just like 'branch labels' or 'HEAD');
- 'annotated', a full object referencing the commit (including tag's author, date, message and commit ID), which can be optionally even signed and verified via GPG (aka "GNU Privacy Guard") [NB: annotated tags are typically used for code-releases];

§ Useful commands for tags:
- create a new 'lightweight tag' >> "git tag <tag_name> [<commit>]" (e.g. "git tag v.3.1.8");
- create a new 'annotated tag' >> "git tag -a [-m "<message>" | -F <file>] <tag_name> [<commit>]" (e.g. "git tag -a -m "release for EMC tests" v.3.1.8");
- NB: if not specified, <commit> = 'HEAD' by default for both the aforementioned commands;
- check details of the created tag >> "git show <tag_name>";
- show all repository tags created >> "git tag".

§ Keep in mind the "git push" command does not automatically transfer tags to RR:
- transfer a single tag to RR >> "git push <remote> <tag_name>" (e.g. "git commit origin v.3.1.8");
- transfer all of your tags to RR >> "git push <remote> --tags" (not recommended).

------------------------------------------------------------

>> 9. GIT-IGNORE <<

§ To keep some files/directories out of Git versioning since the beginning of the project without removing them locally from the WT (e.g. build files generated after compilation, that usually are not versioned), add them to the ".gitignore" file present in the main page of the WT.

§ To remove some files/directories which were already pushed to RR during previous commits, it's not enough to add them to the ".gitignore" file, since even though you stop pushing them in future commits, they still remain stored in the RR. Thus, since they shall be removed from RR first. Follow the procedure hereafter:
- be sure your local branch is up-to-date, there's nothing to commit, and the working tree is clean >> "git status";
- add files/directories to be excluded from versioning to ".gitignore";
- remove files/directories to be excluded from versioning from RR >> "git rm -r --cached <directory>" or "git rm --cached <file>" (e.g. "git rm -r cached bin/" or "git rm cached .gitignore");
- stage changes (i.e. files/directories excluded from versioning according to updated ".gitignore") >> "git add .";
- [NB: the previous command can be alternatively executed over the whole LR via "git rm -r cached .", but that's not recommended since it may create issues in case the project contains submodules];
- commit changes >> "git commit -m "apply .gitignore updates"";
- push changes to RR >> "git push";
- [open the RR on GitHub website and verify the specified files/directories have been removed from the project];
- [try to modify in the WT a file just excluded from versioning and then verify via "git status" that it's not reported anymore as 'modified'];
- [finally, you can either decide to keep the excluded files/directories in the WT or delete them completely also locally].

------------------------------------------------------------

>> 10. BRANCHES <<

§ Every commit belongs to a specific branch (Git's default one is named 'master'), which contains the history of all commits related to that branch. Branches are created by reference and they are useful for code-experimentation/testing, for code development within a team (since they allow concurrent/independent work on the same project without mutual interference), and for supporting multiple project-versions (in case of customization between different applications/clients).

§ Branches can be of x2 types:
- "long-lived" (aka "base", such as 'master', 'development' or 'release'), related to stable and official versions of the project over time;
- "short-lived" (aka "topic", such as 'bugfix', 'hotfix' or 'feature'), related to tickets that shortly merge back to a 'long-lived' branch.

§ Useful commands for branches:
- show all branches of the project >> "git branch" (then the branch marked with the '*' character represents the one currently pointed by 'HEAD', i.e. the one present in the WT at that time) [NB: use "git fetch" before to be sure you're up-to-date with the RR];
- create a new branch in LR >> "git branch <branch_name>" (then check this has been successfully create via "git branch") [NB: before creating a new branch (e.g. 'bugfix_startup_327') be sure to checkout to the desired source branch (e.g. 'development')];
- push a new branch (just created in LR) to RR >> "git push -u origin <branch_name>" [NB: '-u' = '--set-upstream'];
- [NB: new branches can be also created first on RR as well (e.g. go to "github website > project > view all branches > new branch" and choose the source-branch), then locally use "git fetch" to check if new branches are present on RR (then after executing "git checkout <new_rr_branch> && git branch" the new branch is listed also locally)].

§ The "checkout" command can be used to:
- switch 'HEAD' from the current branch-commit pair to either the checked-out 'branch label' (i.e. to change branch >> "git checkout <branch>") or 'commit id' (i.e. to change commit on the same branch >> "git checkout <commit>");
- update the WT with files/directories from the checked-out branch/commit;
- be able to commit for that branch locally and remotely (i.e. to both LR and RR);
- [NB: "git checkout -b <branch_name>" = "git branch <branch_name> && git checkout <branch_name>" (assuming <branch_name>-branch does not exist yet locally)].

§ Whenever 'HEAD' within the current branch does not point to the 'branch label' but to one of its previous commits that's called "detached HEAD". Keep in mind if you want to work restarting on a previous commit (i.e. 'HEAD~') you have to first create a dedicated branch and checkout to this (otherwise it would create a so-called "HEAD-detached conflict").

§ Use "git branch -d <branch_name>" to locally delete a branch (then check the result with "git branch"). Keep in mind deleting a branch actually means deleting its 'branch label'. Moreover, note that the command fails if the branch to be deleted is "dangling" (i.e. it has commits which have not been merged back yet to any 'long-lived' branch). To solve this, you can decide to either merge it back or force its deletion via "git branch -D <branch_name>". To revert an accidental/unintended branch deletion use "git reflog" (showing LR list of recent HEAD commits) to read the commit-ID of the deleted dangling branch to be restored and then use "git checkout -b <branch_name> <commit_id>". Finally, remember that Git periodically checks in background withing the project the presence of dangling commits (i.e. commits not linked to a branch anymore, since the latter has been deleted) and delete (aka "garbage-collect") them automatically. Then, to delete the branch also remotely use "git push origin -d <branch_name>".

§ Note that a new branch keeps inside also the whole previous history of its source branch (this can be checked easily via "git log --oneline").

------------------------------------------------------------

>> 11. MERGING <<

§ Merging allows to combine the work of indipendent branches (usually from a 'short-lived' branch into a 'long-lived' one). There exist x4 types of merging:
- 'fast-forward';
- 'merge commit';
- 'squash merge';
- 'rebase'.

§ 'Fast-forward' (FF) moves directly the source/base-'branch label' to the tip of the topic-branch and cannot cause conflicts (therefore, it's possible only if no commits have been added to the source/base-branch in the meanwhile). In this case, after merging both branches contain exactly the same commits, thus the base-branch inherits all the topic-branch commits (even if later the topic-branch gets deleted). With FF-merging the resulting commits-history (aka 'commits-graph') is linear, i.e. no commits have multiple parents (this can be checked via "git log--oneline --graph"). Commands to perform an FF-merging:
- after pushing the final changes on the topic branch (i.e. the "merge-from-branch"), switch to the base-branch (i.e. the "merge-to-branch") and pull (even if nothing is assumed to have changed) >> "git checkout <base_branch> && git pull" [NB: as said, 'pull' is theoretically not needed in this case since nothing is assumed to have changed in the meanwhile on the base-branch, but nonetheless it's always good practise];
- merge back topic-branch into base-branch (note FF is always the default type of merging attempted by Git at first) >> "git merge <topic_branch>" [NB: whenever using the command "merge", Git specifies the type of merging is trying to execute (e.g. by printing 'Fast-forward' on shell)];
- verify your base-branch is now 'ahead of origin by 1 commit' and push merge-changes to RR >> "git status && git push";
- [check the topic-branch commits have beeen added to the base-branch, HEAD points now to both branches, and commits-graph is linear >> "git log --oneline --graph --all"]; 
- [delete the merged topic-branch both locally and remotely (see section 10.) - this is not mandatory, but recommended to save space on both disk and GitHub and keep project versioning cleaner (NB: a merged topic-branch is never deleted automatically by Git, it has to be done explicitly bythe user via this command)].


§ 'Merge-commit' (MC) combines the commits at the tips of the merged branhces and places the result into the merge commit. In this case, the merged-commit has always multiple parents. Moreover, MC may cause conflicts if the two branches end up modifying the very same files of the project. The commands to performe an MC merging are the very same as for FF, with the only difference (assuming for the moment no conlifts occur) that when the 'merge'-command is executed Git automatically opens a file (named "MERGE_MSG") where to write (at the very first line by replacing the default message, if wanted) details/explanations about the merging. Note in this case the final merged-commit contains a combination of both branches, thus you have a non-linear commits-graph (check via "git log --oneline --graph").
Finally, remember it's possible to create an MC even for simplier FF cases by using "git merge --no-ff <topic-branch>". This way, the merged-commit will keep track also of the topic-branch existance (thus, producing a non-linear commits-graph). This solution generates exactly the same project files as FF would, the only difference regards the project-history information. In particular, MC allows a more accurate history-tracking (since topic-branches are not concealed), whereas FF can help to keep the history-tracking cleaner; so usually it's a software team decision which policy to adopt.

§ In case of long-running topic-branches, it's always a good practise to periodically merge back to the source base-branch, in order not to stray too much from the latter.

------------------------------------------------------------

>> XXXX. SUBMODULES <<

§ Submodule explanation here!!!!!!!! (@todo)

§ Useful commands for submodules:
- initialize all submodules just after cloning the main RR (only once) >> "git submodule update --init --recursive";
- update/pull all submodules (all other times) >> "git submodule update --recursive";
- apply a Git command on all submodules >> "git submodule foreach --recursive <command>" (e.g. "git submodule foreach --recursive git reset --hard" or "git submodule foreach --recursive git clean -dxf".

------------------------------------------------------------

>> XXXX. EXTRA COMMANDS <<

- "git help" to get a brief explanation about the most common commands;
- "git help [command]" or "git [command] -h" to retrieve info/documentation about a specific command (online or on shell respectively);
- "git --version" to check current Git version installed;
- "git status"
- "clear" to clear shell (Linux)
- "ls -a" to show all files and directories within current folder, including hidden ones (Linux)

- git log + 'q' to exit!
- git log --oneline --graph

- use "git clone <url> [<local_project_name>]" to create a local copy of a RR and enables interaction (i.e. pull, push, etc) with that RR;
- use "git remote [--verbose|-v]" to display information about the RR associated with your LR

- "git gui" to open Git GUI

- after merging back a branch to main, fai checkout to main e status (should be uptodate). then git fetch amd git status, now it should say remote is ahead (?) -> check!

to cancel commits in LR on current branch : "git reset --hard <commit_id_to_restore>" (e.g. "git reset --hard HEAD~X", to cancel last X commits, assuming HEAD is pointing to 'branch label');

git checkout -f <branch> (to move discarding all WT changes not staged/committed)

git commit -a -m "<comment>"


@TODO

submodules example
gitignore file



push + modifico wt + pull >> unstaged files rimangono, i.e. non piallati da pull!


se faccio push da user#1 e status mi dice che sono uptodate with origin/master
se altro user#2 fa dopo push
io user#1 rifaccio statusvedo ancra stesso messaggio di uptodate! >> solo se faccio fetch e poi status allora midice chem mybranchis behind 'origin/master' by 1 commit!!!

stash?

github enables the grph-view ("githubwebsite > insights > network") only for paid versions (enterprise) or if the repo is public!

explain fhow to delete repo or change visibility (between public and private)

check all @todo!!

to check difference between WT and LR open git gui on main repo page (via "git gui")


git log --oneline --graph [--all] >> senza --all vedi solo commit history del bracnh corrente (su gui hai fatto checkout + di recente), con --all cisono tutti i branhc in parallelo!






- prova a creare branch, fare push su RR e risolvere conflitti quando rimergi su master
- prova a creare tag su un commit (tipo per release)
