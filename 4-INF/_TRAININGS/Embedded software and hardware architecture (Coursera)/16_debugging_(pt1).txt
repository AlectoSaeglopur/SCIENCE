In this video, we will go over features of the debugger. Most software engineers like to think that they write perfect code. Far from it. You are likely to introduce a few bugs every couple of hundred lines of code you write. Sometimes software bugs can be found by inspection, other bugs may even go undiscovered for years in a project. Luckily, lots of modern tools help track down and fix bugs. Some bugs will be found through static analysis tools or good compiler error comments. The bugs that make it through compilation that are not obvious are the hardest ones to track down. In this video we will go through the features of the debugger that will help find these interesting bugs. Every software application has to go through some testing process. Usually this would involve a debugger. A debugger is an application that connects to your desired executable and allows you to observe and control your software application. There are many features of debuggers. Some require hardware and some don't. Some debugging sessions can be run on a host machine purely in software. A popular debugger is the GNU Debugger or GDB. For embedded systems, we typically have supporting hardware that helps us connect, program and debug active applications on an embedded system. Additionally there is a software application on the host machine that controls the operation through the debugger hardware. Combine these with an embedded system and you have your debug environment. In your case, we will use code composer studio, IDE, and the integrated debugger to remotely debug the MSP 432 micro-controller. The first step to debugging occurs during compilation. In order to debug an application, the target must be compiled with debugging symbols enabled. This allows a debugger to interpret what the program is doing and map that to the compiled code and the symbol table from the executable. The bug application usually runs remotely and you connect to that hardware and send data back and forth between the platform and the debugger to check on the status of the program. After the application is built, you need to install it into the platform for. This you will need a bootloader or the programmer debugger hardware to program the flash memory. The debugger typically has varying access depending on supporting hardware. ARM provides a built-in debugging port called the DAP or the debug access port. This allows us to control many aspects of the CPU. This port also provides support for multiple debugging interface standards including JTAG and Serial Wire Debug or SWD. Depending on the debugger, there can be multitude of supporting features. Important ones include the ability to set breakpoints and watch points, inspect memory, read and write to the peripheral registers, inspect assembly and even monitor your stack trace. Let's go over a few important features before we introduce how to do a full debug. Breakpoints are a tool used in debugging to stop or pause the current execution of a program. Breakpoints are extremely valuable for inspecting the processor state at any point in time. The processor is prevented from moving onto the next instruction once it hits a breakpoint. The program needs to be restarted before continuing or can be controlled to single step through your program. Typically there is a limited number of breakpoints you are allowed on a platform. You would set a breakpoint and then use other features of the debugger, to read memory or inspect variables during the pause state. Watch points are a tool used to create a breakpoint in the processor when a specific value of a variable or expression changes. This could happen at any point during your program. This is useful if you're trying to polish your microcontroller when a particular event occurs, perhaps when a variable is changed or reaches a certain value. One important note about breakpoints or watch points is that if your system is receiving data or information from a source external to the microcontroller during the time the processor is paused, it is likely you are going to miss that data. This is because the normal operation of the microcontroller is likely handling the incoming event. But currently it's prevented from doing so because it's processing previous events and it's been paused. Debuggers give you access to the current scope's variables. This allows you to inspect the value of any local variable at any point in time during a function. You must be paused before inspecting variables otherwise no data can be read. You can typically change the value of these variables as well during runtime. There is an additional menu to inspect the global variables or other expressions that are outside of the global scope. This can include general memory locations, global variables or even peripheral registers. In this expressions tab you can write C programming statements to cast and dereference memory locations and pointers to get a closer look at your data. Some debuggers allow you to investigate the registers, including core CPU registers and peripheral registers. This is a useful feature to use in parallel with breakpoints because you can inspect specific elements during your program. Just like variables, you must pause your program before you can inspect these elements. Some debuggers even allow you to change the value of these peripherals during runtime in the Debug menu. This is useful if you want to correct a minor code error or test the behavior of the microcontroller at runtime without recompiling and re-uploading. You can also look at memory through a memory browser. By opening the memory browser you can select any point in the memory map and read and write to that location when the processor is paused. The memory browser typically provides a feature to allow you to format the data space in a certain way to make it more readable. This could include listing the memory as a location of byteblocs, word blocks or a different number representations like hexadecimal. One last important feature is the stack trace. This allows us to determine where we are currently at in our program by investigating the stack. This is less important for a simple program without many routines. It's really important when you're starting to debug concurrent software applications with multi-threading. There could be many different threads calling the same function and you might not know which thread called that. So you would use the stack trace to determine which context resulted in that current function call. Debuggers are extremely important in software programming. These help you track down bugs, validate your software functionality and speed up your development time. Many people use command line debuggers like GDB, and others prefer use a debugger with a UI oftentimes running GDB behind the scenes. In any event, the debugger can help track down most problems that a programmer might see. There are cases when you do not have access to a debugger or a bug occurs in the field. For this we'll need to introduce other software concepts for testing and debugging in future courses.