In this video, you will learn how to use some advanced pointers in software. Pointers are one of the most important software constructs for embedded software. Everything is interfaced via an address in the memory map using a pointer regardless of the memory being used for data or for peripherals. The pointers we have worked with in this course are all known types: Integer Pointers, Floating Point Pointers, Structure Pointers, and many other built-in C types. Pointer declarations explicitly provide the underlying data type they will dereference. There are some different types and qualifiers that we have yet to discuss that can provide more flexibility with coding, as well as some performance improvements. Let's introduce three new pointers that we have yet to discuss. These include Void Pointers or Generic Pointers, Double Pointers, and the Restrict Qualified Pointer. You might have wondered, can you just track generic address information without giving a defined type? Or, will you ever need to have a pointer that points to a pointer? And lastly, will there need to be a guarantee that the memory location has only one pointer pointing to it? The answer to all these is yes, and they are constantly used in firmware design. So, let's go into detail in each one. Starting with the Generic pointer or the Void Pointer, this pointer is used whenever you need to just store an address. Meaning, you are not necessarily interested in dereferencing the underlying data, but just tracking a memory location. A Void Pointer is the same size as other pointer types in the system, the size of the word. Void Pointers should not be confused with a Null Pointer. Void Pointers can contain a Null Pointer value, though, you should not directly dereference a Void Pointer. You should cast it before interacting with the underlying memory. Additionally, you cannot do pointer arithmetic on a Void Pointer. This does not make sense because the Void Pointer has no concept of the type of data it is pointing to. You've seen the example of Void Pointers before when using dynamic memory functions like Malloc and Free. Malloc returns a Void Pointer as a result of allocation of some number bytes. Malloc is not concerned with what the data is being used for, so it just passes back a Void Pointer for you to cast to your own pointer value. Pointers can be cast into other types easily in software. However, casting pointers can have impacts on performance. For example, a pointer might be casted to a different type that is not aligned. There are cases where we may not know what the underlying data type is until we have started processing it. Sometimes, you need to analyze some parts of the memory being pointed to in order to fully understand the underlying type. This is the case with software interfaces. You might have two embedded systems that are communicating via software interface. This interface may support many different messages of different sizes and identifiers that go in between these two. These messages would translate to a data structure in C programming that is passed between two different software applications. The structure may have a header field that tells the receiver exactly what type of message it was going to receive. You may need to interpret the header first before you could understand the full body of the message. We will go into more details about software interfaces in a later course. The next type of pointer we'll talk about is the Double Pointer. A Double Pointer is just a pointer to a pointer. A Double Pointer is declared with two stars and it needs to point to another pointer of the same type. This is useful when developers need to set the value of the pointer variable itself. In other words, the address. And then, pass that in and out of a function. You can use the same address of operator we used when we assign a pointer and address to provide the address of a pointer. This will in turn be the address of a pointer which is pointing to a different address. When you pass a pointer into a function, a copy of that pointer is made. And inside the function, the programmer is free to change that copy pointer or change the data, the address location. External to this function, the pointer variable passed then does not change. It may point to some data that was altered by the function, but the underlying address of the pointer external to the function remains unchanged. Here's an example where we're allocating some memory in a function. The function is defined with a structure Double Pointer. This function will allocate the structure dynamically and initialize it before returning. No need to return the pointer variable because a pointer was passed into the function, that can be modified. The last point we will discuss is the Restrict Pointer. The C keyword restrict is a type qualifier that was introduced in the C99 standard for pointers. Restrict tells the compiler that when this keyword is used for a pointer, the compiler can potentially optimize the memory interactions. Unlike other type qualifiers, the Restrict keyword must come after the pointer asterisk, but before the pointer variable name. The biggest beat up you will get in execution is when you're working with large arrays of memory. Say, you are running some computation over a large data set. The compiler will see the Restrict keyword and optimize the iterative operation by removing some of the unneeded assembly instructions. This is because Restrict tells the compiler that this memory is not overlapped with any other parameters or aliased to other pointers, and then it can go ahead optimizing the interaction with memory. Couple of unstructured savings per loop can provide a massive amount of speedup over the full memory operation. Pointers are truly useful not only for interacting with microcontrollers, but also for helping create abstracted software interfaces. Void Pointers are used to track generic addresses. Double Pointers allow us to change the address a pointer holds. The Restrict keyword allows the compiler to optimize our code more. These concepts are somewhat confusing the first time you learn them, but are regularly used in software development.