Welcome! In this video, we will introduce mechanisms to access and manipulate memory on an embedded platform. As you recall, microcontrollers have a variety of memories and peripherals. Manufacturers will have numerous versions of each chip within a chipset family. By doing this, they can provide multiple chips with different amounts of functionality and memory capacity. You will likely use multiple chips throughout your career, each chip having its own platform specific requirements. It will be important to know the different tools you have at your disposal to make your code portable across platforms, also having platform specific functionality. You've already been introduced to a few of these concepts before, such as a linker file and the register definition file. In this module, we will dive deeper into these concepts, and provide you with the tools needed to access and manipulate a variety of memories inside a microcontroller. We have already built a strong foundation understanding code, data and register memory. These memories are numerous in a microcontroller and we interact with them on every clock cycle. Most of the operations we execute involve data memory. This data needs to be loaded and stored with the use of pointers. So far, we've discussed simple C pointers that point to C standard data types and structures. There are other pointers that allow increased portability and manipulation of our memory. These include: void pointers, double pointers, function pointers, and restrict pointers. These advanced pointers will provide us a new mechanism to interact with memory, and pass information around our program. To operate on data memory, we loaded the data into the CPU then operated on it, and stored it back. And much of that data manipulation, we did in the microcontroller was done at a bit level. This is referred to as Bit Manipulation. By using C programming, Bitwise and Arithmetic operations, we can interact with data smaller than our traditional C program sizes. This is even more important when we interact with peripheral registers to configure a microcontroller for its particular application. A peripheral is a piece of hardware external to the CPU that helps perform some specific functionality. You might ask, what peripherals does my microcontroller have? What functionality does a peripheral provide me? And how can we configure this peripheral? To get this information, we need to look at the manufacturer's documentation. The Technical Reference Manual does not provide all the details on memory, but instead, a general guide across the entire chip's of family. We would also need the datasheet to know exactly which chip model has which functionality. By opening the Technical Reference Manual to a specific peripheral on a microcontroller, we can learn how the device works, the features, as well as how we configure it. Each peripheral has a subset of registers. These registers are a mixture of status, control, and data. To find out how to use them, detailed information is provided in the reference manual. And in order to interact with them, we need pointers to their addresses. The register definition file for our platform provides us with our software mechanism to interact with these registers. And once having the knowledge of how to interface with the component, and an access method such as a pointer, we will just need to know how to manipulate registers made up of bit-fields. Data memories is not the only memory we're going to want to manipulate or work with. We will introduce some concepts with code memory, that allow us to reduce the overhead of calling a function. Inline functions and macro functions will provide us two examples on how to write code that can execute more efficiently, but with some drawbacks that include readability and increased complexity. Additionally, we will use function pointers, which will allow us to dynamically change which functions execute, and also associate a function within a data structure. This module will provide an example of configuring a simple input-output peripheral to blink_LED using everything we learned about memory, memory access, and data manipulation. In this example, we will look at the memories of a microcontroller, and how they change for the execution of a program. We will do this using features provided by an integrated development environment and providing some demos. Learning how to utilize specialized memory access interfaces, we can now begin to configure a microcontroller, and understand the details of each line of code we write, as it interfaces with memory. With more advanced pointer use and increased data manipulation, we can write efficient and effective microcontroller software.