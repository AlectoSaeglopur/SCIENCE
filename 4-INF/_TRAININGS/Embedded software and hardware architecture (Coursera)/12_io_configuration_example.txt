In this video, we will look at an example of using bit manipulation to configure a port pin on a microcontroller. Nearly all peripheral functionality external to the CPU that you interact with requires the same process to configure and operate. To configure a microcontroller you need to be very comfortable with bit manipulation, pointers, register definition files and reading reference material. For this video, we will do a simple example of toggling a port pin between high and low to turn an LCD on and off. This example can transfer in concept to most other parts of the microcontroller. We will cover other peripherals in more detail later in the course, but with a background and memory interaction we can now finally start working with our target embedded system by using an IO device. Input output or otherwise known as IO is the fundamental way we get data in and out of our microcontroller. IO has many different names across chipset manufacturers such as GIO, IO and GPIO. GPIO stands for general purpose input output. This is just a way to read or write ones and zeros from our microprocessor out a dedicated pin. Multiple pins are usually mapped together into a larger grouping called the a port. Ports can have a range of pins depending on the manufacturer. For the MSP432 we have one to eight pins per port and a total of 10 ports. Each pin and port will also have a primary and multiple secondary functions such as serial modes and analog input modes. For the MSP, pins are given a name regarding their PIN number and port number. For example the pin 0 of port 1 is P 1.0 and the seventh bit of port 1 is P 1.7. We do this so it's easier to track our port pin combos instead of memorizing exact PIN numbers on the microcontroller. The first place to start with any microcontroller programming is the reference material. The data sheet and the launchpad schematic can provide us with specifics on what connections in pin functionality are available. For this example we need to find out what pin is connected to the right LED on the board. Located at the bottom of this board is a small LED that will be the red LED we're going to configure. Now even though there is a P 1.0 listed on this board itself, we will still look at the schematic to get some more information. Looking at this diagram you can see that there is a resistor R7 and LED connected to the pin P 1.0 or the microcontroller. By writing a high to this pin P 1.0, the LCD will turn on. If we look at the datasheet in the section called pin diagrams in signal descriptions, we can see that the P 1.0 LED is located at pin four of the microcontroller. This document also lists alternative operations for each pin. If you were designing your own board you would look here to find which pins are capable of certain peripheral functionality. Now in order to turn on this LCD we need to configure the port pin to output a logical high. This will require two steps. First we need to set the direction of pin to be an output. And second we need to set the output voltage to be a logical high or VCC. VCC means the voltage supply of the chip and it matched to 3.3 volts. We already know that this LED is connected to pin 0 of port 1. But how do we configure this direction in output setting? If you open the technical reference manual to the section on digital IO, we can read up on how to configure the pin. You should read through the section to get a basic understanding of IO. But we will cover more of this later. Most importantly we will want to scroll down to the registers for the port 1 IO device. Here we will see two important registers. The port X direction register and the port X output register. Our GPO pins utilize the same configuration for ports. The x represents any port from 1 to 10. Each bit in these registers represent a different pin in the port. Bit 0 is pin 1.0 and bit 7 is pin 1.7. Looking at the port X direction register or P1 DIR, we can see that if we set the port to a zero the pin is configured as an input. If we set it to a one the port is configured as an output. We are going to set the bit 0 to a 1. In this case P 1.0 to make it an output node pin. Some interesting things to note about this register is that every bit has an rw-0. This means that the manufacturer is telling the programmer that these bits are both read and write. However they also have a default value of a zero or input. When you write your software you should always explicitly set a configuration in your code so it is clear for other users to know what you did without any assumptions and also in the case that there could be errors in the data sheet in terms of initialization. Looking at the port 1 output register P1 OUT, we can see that when the pin is configured in an output mode writing a zero to the pin will set the output to ground. Conversely writing a one to the pin will set the output to a high voltage. It is very important to note that we need to configure both direction and output value in order to interact with this LED. The P1 out register requires our direction to be configured in an output mode first to even turn it on or off. Now it's time for us to write the code. Here I've opened up code composer studio or CCS, the integrated development environment for Texas Instruments. I've configured a project to work with our MSP432 development kit. We're going to be using this kit to blink an LED on this board. I'm going to write code in the main.c file I have opened up. Notice I've included the MSP header files necessary for the MSP432 device. Details on how to do this will be covered later in the course. There are two ways to create a software interface to these port registers. First is by knowing an exact address of the register and creating a pointer of that type that matches the width of the register to manipulate. For the port direction register, we have an eight bit register size so uint8 pointer will work. We need to cast the integer address and assign a pointer variable. Now we can dereference this address and set any configuration we're interested for, for the specific port. We could also even directly dereference this piece of memory. I have looked up in the reference material and I have listed the addresses for the P1 OUT in P1 DIR registers here in the code. I will use our bitwise operations to or equal to one, in the zeroth bit to set the direction. I will then loop on the P1 OUT register with a for loop toggling the output value between zero and one. I will now compile this code using CCS and press the debug button which will upload our code to the MSP432. Now I will press play and we can see this LED blink. The for loop I chose here has an arbitrary length, but I chose it in a way that the blink happened slow enough for us to see. Alternatively I can use the register definition file interface and use the port one DIO port structure overlay. This access method will allow us to write in the same direction and output registers. As code will function the exact same, they both dereference a peripheral memory location to read and write bits. Structure overlay method requires a structure dereference operator. If I compile and upload this code, you will see the same LED blink. I will finalize this example by removing my hard coded values and using a predefined bit mask to toggle this bit. This will make my code more readable and much more maintainable. Again it is important to note they were using bitwise operators combined with the assignment operator. I'll also change the for loop length so that we can see the blinking happening at a different rate. This video provides us our first practical micro-controller example, where we use pointer access methods, bit manipulation, reference material and the ID to configure this LED to blink. We begin to learn about many other important peripherals and we can configure other software using these techniques to make our process to work more efficiently and correctly.