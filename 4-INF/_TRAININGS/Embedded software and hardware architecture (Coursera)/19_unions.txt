In this video, we will talk about Unions. Software developers allocate some type of data in every program, whether those are constants, dynamic memory, or local variables. Usually, all of these have a fixed data type which is immutable. Meaning, once you declare a piece of data, you cannot alter its type. This may or may not be desirable. Maybe you want your type to be more dynamic. What if you have a piece of data memory that you want to interpret as one type in one function and a different type in another? C programming provides a type to help with this called a Union. That will allow us to reuse a variable and interpret numerous ways depending on the types how it's defined. Unions are a special type that allow a software engineer to define a structure-like type where all members occupy the same address. Unions are declared with a Union keyword. Unlike a structure, where each member comes one right after another in memory, each element in a Union has some overlap with other members defined in the same type. Depending on the size, there would be more overlap. Unions can contain multiple members of different sizes, and they are accessed in the same way that you access members in a structure. You will use the dot operator, or the inner operator, if you have a Union pointer. The size of a Union will be equal to the largest individual member. And a Union can also be typedef for shorthand declarations for that Union type variable. Here are a few examples of a Union. First example shows a simple Union with three members, X, Y, and Z, each a uint8_t. The Union size is one byte, even though there are three members. If you were to investigate the address of the Union, as well as each individual member, you would see that they all share the same address. I can assign data to the individual members. If I first assigned to the X member the value of 13, then a Union will contain the value of 13. In fact, all members, if you were to read them, would contain that value. If you now set the value to the Y member, to 65, then the X value will now be overwritten, as well as the Y. A second example defines a Union with multiple different sizes of members. Here, we have a Union with a 16 byte array, a uint8_t variable X, a uint16_t variable Y, and a uint32_t variable Z. The size of this Union will be 16 bytes because the largest member in this Union is the array, which is 16 bytes long. No matter how you use this Union, it would always allocate 16 bytes, even if you've never referenced the array variable. Again, all of these variables occupy the same address. The difference is that each of these extend further into that 16 byte allocation. A third example defines a Union containing structures. Here, we have a Union with two structures defined inside of it, structure one and structure two. These two structures have completely different implementations. One is created with three uint8_t members and the other is created with three uint32_t members. If you wish to modify either one of the structure members, you can do so with a double dot operator to access the member of the structure inside the Union item. However, by modifying one structure, you will also change the other structure's data. Unions are used regularly in the header files for the Core Microcontroller Software Interface Standard, or the CMSIS, provided by ARM. Let's look at a few examples for the program status registers in the control register. In these examples, a definition was created for each Core CPU Register using a Union. The Unions allow for interaction with the register via structure in bit fields, or by a word size data type. With the word size data type, you would need to do your own bit manipulation to access the bit fields in this register. C programming bit fields provide a built-in way to simplify this bit manipulation. We will cover that in an upcoming video. Unions are typically a confusing software construct for developers. However, here I have a good example to show how a Union might be used in an embedded system. In addition to the previous course, CPU Registers, let's do one with shared memory. Imagine two different functions that may need to have a sizable piece of memory to do some data processing in, and these two functions will be regularly called independent from one another. They will never be running in parallel, they will run to completion, but another might get called. You may not have enough space to statically allocate two full regions, one for each of these functions. Also, allocating and deallocating this memory individually will create unwanted overhead. What if instead, both functions use a shared resource that is just made up of a block of memory? You may allocate this memory at the start of your program to reduce the overhead at runtime, and both interact with that one piece. When function one needs to use this memory and they want to interpret this space as a large bi-array, like a character array for string printing. Function two may want to interpret this memory as an array of structures, say, a space to track the movement of a ball in space. We'll call that structure, movement. When each function runs, they use a Union variable, and they access their specific Union variable to interpret the space. In reality, these are not necessarily functions but instead, threads in a program running on an embedded operating system. A process may provide this shared memory region as a resource to each thread to get used for some amount of time as a storage place for its data. This shared resource across two functions allows for efficient reuse of memory without excess overhead, allocating, and deallocating for each function call. A space can be allocated in global memory, or a compile time, with the linker file, to configure this resource to start with. Unions are a confusing feature in C programming but they allow for more dynamic use of a piece of memory where you can interpret more than one way. A developer may want to reuse a memory location with multiple different types. Combining Unions and structures can give us a powerful mechanism to manage and manipulate our memory.