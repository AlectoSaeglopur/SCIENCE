In this video, we will learn how to create and use a Function Pointer. In C programming, we have many different types of pointers. We had integer pointers, phone point pointers, structure pointers, and double pointers. All these pointer types, point to the same underlying item, which is data. The data we have pointed to is, either data memory or peripheral memory. Void pointers, differed from these because they're just generic pointers. They can point to any address. Data is not the only thing we can point to. We've had pointers, point to constant data in code memory as well. But, we can also point to code itself. Not only can we point to code, we can use a code pointer and execute a particular function being pointed to. This is referred to as a function pointer. A function pointer is just like a pointer to a software routine. The size of the function pointer is the same size as other pointers, the size of the word. Function pointer differs, in that it points to code in code memory. Function pointers can be defined to have a return type, and input parameters just like normal functions. Additionally, function pointers, can be dereferenced. This dereference does not access data, but rather when a function pointer is dereferenced, it will execute code. Let's go into a few examples of function pointers. The syntax for a function pointer is slightly different than most pointers. To properly declare a function pointer, you start with the type, following by a set of parentheses. Inside those parentheses, there is an asterisk followed by the function pointer variable. These must be in the parentheses, to distinguish the function pointer, from a function, that returns a pointer. Following the pointer and function name is the parameter list. The function pointer can be assigned to other function addresses, just by setting the function pointer variable, equal to other function addresses. You can use the function name or the address of operator to do this assignment. Function pointers can be declared, just like other variables, locally, globally or even on a structure. Not all functions can be assigned to any function pointer. A function pointer declaration must match that, of the function it's pointing to. For instance, this function foo, has an int return type and two input parameters. A function pointer must be declared with the same types. You may even want to generalize your function pointer type, with a typedef. By using the typedef, we can now define as many function pointer variables, with our typical declaration shorthand. Here, I have a defined multiple function pointers. These function pointers must point to defined functions. When compiled, you will dynamically call the function from code memory, when the line of code is executed. You can also declare an array of function pointers. This would be used, to spatially locate entry points to functions, in an array, that can be used for things like state machines, API's, or for interrupt vectors. A syntax use a mixture of array and function pointer notation. Inside the function pointer parentheses, you need to include array brackets. For a function pointer array, you may also declare an enumeration type, to index into your array, in order to access the right pointer of interest. Now we can use the function pointer type, FuncPtr, and declare an instance, called example. We can use our enumeration index, into our function pointer array, to access different functions. Here, we have two examples, Calling function one or function two, using the same function pointer array variable. One of the most important uses of function pointers, is the Interrupt Vector Table. Interrupts, are a synchronous events, that request the processor to stop processing the code and main, and instead process a small routine, in response to this event. These events include things like a timer, a button press or an exception event initiated from some fault of the processor. The table is effectively an array of void pointers, that point to functions in interrupt subroutines. The vector table is also typically the first section of code memory, in our code segment starting at address 0. The vector table definition requires both software and linker script changes. It utilizes a function pointer array definition. Here, we have a vector table defined for the MSP432 Cortex-M4 micro-controller. The array starts with a pragma, that associates this function pointer array variable, interrupt vectors, with a linker script data section called, the intvecs. If we look the linker script, you can see the top section in the program sections, is the intvecs dataset. Notice this is being mapped to address 0, and then it's followed by all the declarations for the code text segments. Going back to the function pointer array, we follow the pragma with an actual declaration. All interrupt vectors are void functions, with no parameters. The declaration starts with a void const function pointer. Notice, the function pointer has the parentheses syntax, for the pointer as well as the array notation, after the interrupt vectors variable name. This is declared as a const, because we do not want to alter this array. We want to prevent code from altering these function pointer values at runtime. Then this array is initialized at every function that is being used for the interrupt vectors. The vector table starts with the initial stack pointer and then the highest priority exceptions like the reset interrupt, the non-maskable interrupt and the various fault handlers. Further down, there are general peripheral interrupt routines, as well as ones that are not defined for this architecture. We will go into more detail on how the CPU uses this vector table in future interrupt lectures. Function pointers are used everywhere in programming. In Micro Controllers, all Interrupt functions are stored in a function pointer array called the interrupt vector table. Function pointers, are used for concurrent software applications as well and function pointers can also be used in structured definitions. Function pointers, provide a more dynamic way to call code at the expense of readability. However, it is a powerful feature that is used in software design.