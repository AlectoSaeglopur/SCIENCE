In this module, we'll be introducing
the concept of version control of Git. Version control will be used
to track our software changes. Instead of just saving our
files over our original files, we'll have a method of seeing every
change we make to our software. As our projects grow, large,
we can review very old changes. As our projects change support for
different modules or even standards, we can keep a history of
those changes within version control. Version control systems, or VCS, or alternatively revision control systems,
RCS, is a software package that allows users
to track changes in a project over time. The VCS gets installed on the host
machine where you develop your code. There are many different version
control systems you can choose from. Concurrent Versions Systems,
CVS, subversion, SVN, Mercurial, IBM Rational ClearCase,
and Git. Git is what we will use in our course. Git has become an industry leader in VCSs,
with many major players using Git, such as the Linux Kernel,
Google's Android, Twitter, and even the GNU Tool sets that we
will use later in the course. The VCS allows you to track items such
as software, documents, build and configuration information, or
even a projects compiled build release for customers that download. The system appears like a normal
file system full of source and header files organized in some
arbitrary folder structure. Also, there are hidden files that
are not visible from a software develop perspective that contain the configuration
and tracking information for your code that is managed
by the VCS system itself. This collection of
software project files and version control files is call
the repository or a repo. In a Git repo, configuration and
management files are stored in a folder called .git and
these should not be modified by the user. All changes and interactions
should be done via Git commands. Each different software project will
have its own distinct repository and you can even combine multiple
repositories like components or plugins to create a large
software project. There are many examples of this such as
Google Nexus devices or other cell phones. These devices have many repositories that
are built together and installed onto different processors inside the phone
to create a complex software project. Some repositories that are included
in this may be, modem software for radio technology,
operating systems repositories, platform repositories for firmware or
how layers, user interfacing and graphic libraries for displays and
build configuration libraries. Each of these repos have its own
launch and complex software design. Without all combined together for the full
platform the across team collaboration of probably hundreds of engineers,
we wouldn't have such an advanced device. Each Git project contains all changes
made in the history of the repository from one folder structure. This creates a very maintainable and extendable software platform for
development. Each historical change that is
tracked is called a commit. A commit is a bundle of information
including textual software changes In commit tracking info. This tracking info is
referred to as metadata and includes informative items such as
the user and email of who made the change, date of the change, a file change list, an
informative comment regarding the commit, and a unique SHA-1 hash ID used to
identify this commit in the repository. As you commit new changes, you log the change along with
this metadata to the repository. And over time, you can refer
back to any of these commits and see exactly what was changed by who and why simply by referencing these
commit SHAs or commit IDs. Each new commit contains information
on the changes from the previous state of the repository,
otherwise known as the parent commit. By effect,
Guinness actually tracking the deltas or the changes in between
each successive commit. Not every file may change, so less information is stored in
between each version or each commit. This examples shows only one commit but
you can see that current change of commits and parents back to the beginning of
the repo using the git log command. This command shows a small excerpt of
the commit metadata in a list view. All changes you make to your repository
stay local until you push your changes out to the remote repositories. Oftentimes, you keep a central, or master repository where all users
push their changes for collaboration. This remote repository is often
referred to as the origin in your local Git workspace. Also, you may track any
other coworker's repository by mapping them as a remote in your
local repository with a unique name. That way, you can share content
directly with these individuals and be immediately updated when they make
changes to their own local repositories. Access to the repository
is dictated by the owners. Companies will store a private
repositories on internal servers to protect their intellectual property. While open source projects will make their
code available on repository store sites, like GitHub, BitBucket, or SourceForge. If you need access to
an existing repository, you can perform a clone of the repository which copies the content form a remote
location down to your local machine. If your software project is new, you can create your own repository
using git initialization command. This will create a local repository that
you can back up any of your code and then store on a remote git repository
server site for safekeeping. When you are ready to start making
changes, you can follow a simple workflow. You start by creating
a development branch. A branch is just a way to organize your
changes without affecting the code base and indicates that you're going to diverge
from the main line of development. You can name your branch
whatever you want and you can maintain many different branches,
tracking different features and bug fixes within the same repository
without them affecting one another. Once you create a branch, you can begin to make changes to your
files with your favorite file editor. Once you make a change,
you stage the file to be committed. When you're confident with the change,
you commit the change and the repository logs and you commit. New files are referred to as untracked
files in your Git repository. They will need to be added
to source control so that your Git repo knows they
are meant to to be tracked. Any changed files are called
modified files and they will need to be staged
before being committed. At any point in time you can used git
status command to see the current stage of the changes you currently working on. Once a change is being committed, you
can push that change using the git push command to a master repository
rather users to sees news. They can collect and pull down your
changes to their local repos by using the git fetch or the git pull commands. As more contributors add to a single
software repo, the need for creating a team workflows developed. This is because developers will eventually
make changes that conflict with one another as similar files or
lines of code need to be edited. Conflict resolution is unavoidable
as collaboration grows. Resolving conflicts is done by analyzing
the differences between software sets and creating a new commit that represents the
merge development of the two developers. Somewhat of a manual process is used
to merge conflicting files into a single file. Tools like git diff allow you to
investigate the changes in files around focused areas between commits. The commands that help trigger and start
conflict resolution are performed by using the git merge program or
the git rebase command. Here, we will do a short
version control demo. I will use two terminals to show output. First I'm going to clone of a repository
from a remote git server with the git clone command. I will cd into this repository and
I can list all the files there. Next, I record myself as the commit
author by setting my name and email in my Git configuration
using the git config command. This could be a local configuration
change as in this repository, or a global configuration change as
in all of your local repositories. Next, I will show you the current
status of the repository by using the commands git log, git branch,
git show, and git status. This will show what the current
history is, the current branch, the current tip commit is, and
the status of the repo changes. The current tip commit
is referred to as head. Git status should return no changes
because we have not made any yet. Now let's create a branch based
off the remote repository origin which represents my
master repo on the Git server. We will create a branch with
the git branch command. I will base this branch
off of origin/develop. This is just a local copy of
the remote branch develop. Now, I will check out the branch
with the git checkout command. If I rerun some of my status commands
such as get branch and get status, you will see that we have changed branches
and there are no file modifications. Now it's time to make some changes. Here, I'm going to edit a file by changing
some arbitrary lines using vin file editor Once I save the file, git status will show that there are
modified track files ready to be staged. I will add the file to be
staged with the git add. I will then commit
the file with git commit. The git commit command
opens up a Vim editor. Here, I will type in
a good commit message. I will save and exit. The commit has now been made. Vim was automatically opened as an editor
because I had Vim set as my default editor. You can see your default editor
with the echo editor command and you can change it by
running the export command. Finally, I want to show you how the
repository has been updated with commits on my current branch. Here at the head is my new commit. My commit has a unique SHA as well as
other metadata like the time and commiter. I can even use Git to show how this
commit is different from other commits with the git diff command. If I diff the current tip my branch
with the point of divergence, the origin development branch, you can see that the only change between
the two are the one line of code I made. You can diff between any commit
SHA branch in your repository. Now I will push the change out to
the remote repository with the git push command. With git push, you can let it
push using default parameters but I suggest you provide
some more information. Here I have told git to push my
changes to the remote origin. Next, I have told it what change to
push that commits on my branch demo. I have also told it where to push those
changes too, the remote develop branch. If you do not have SSH key set up,
you will have to provide credentials for pushing access. This succeeds and now I will update my local copies of
the remote branches with git fetch. I suggest using git fetch as it does not
try to perform any local updates of your local branches. The use of version control
repositories is essential for software project development for
many reasons. By tracking changes in the repository, it allows developers to perform analysis
through the history of the code potentially even backing out
changes because of bugs. The commits in metadata provide
tracking information as a way for teams to map features and
bug fixes with past tracking software. Version control advocates
collaboration and co-development in the distributed
development environment by providing a mechanism for
all users to be up-to-date on changes. This is an added effect of backing up
the repository across a slew of developer machines all who have copies. As we move through the course and
you write your own software, you will create and manage your own
Git repository to track your code. We will build off of that code as
we move through various courses and we build a project. And you will leave this course with
a repository that can act as a core portfolio for you for
your own professional use.