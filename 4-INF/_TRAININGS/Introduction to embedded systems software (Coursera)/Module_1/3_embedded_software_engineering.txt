In this video we'll introduce concepts
needed to design and write software for an embedded system. Software engineers often want to jump
straight into coding before putting time into code design and architecture. Good software design needs to
understand what the purpose and required operations specifications
that a project needs. It's good to start by breaking a software
concept down into flow diagrams or software blocks a flow diagram can depict,
how a particular piece of software or algorithm should behave. Often it contains a same
functional software contracts, such as conditional decisions and
high level function calls. Software Block Diagram did not differ
greatly from a hardware block diagram, you often see for circuit boards and
micro controllers. Instead, they depict how different
blocks of code communicate and connect to one another. That being said, a Software Block Diagram can also
depict a software system in layers. An example of a typical software
organization can be seen with an OS-based design. There are low-level Device Drivers
that interact with Hardware. There are software to help boot or
start the system. There's an operating system to schedule
processes and manages resources. There are shared libraries that
many software components use and finally the higher level software
reflects user applications. Writing code to direct the interface of
the hardware is referred to as bare-metal firmware. Their metal code has
a steep learning curve and we will be focusing on this in the course. A firmware engineer requires deep
knowledge of the hardware, not only for configuration of the bare-metal but
also for hardware timing and limitations related to
their software design. A software engineer's role will be to
try and segment the hardware interface into something referred to as a HAL or
Hardware Abstraction Layer. By design this interface works as a module
component but they well defined interface. It allow software above the HAL layers
become platform independent or agnostic to the specific hardware implementation, a
concern layers, portable across platforms. In general for each of the box in our
software system, you need to know what the responsibilities are and how the
different blocks interface one another. This is especially important, the pieces that need to interact
with the underlying hardware. We also need to put some time into
understanding the hardware specs that affect the software design as we
try to engineer the best solution. Remember embedded systems are highly
specialized with limited resources. A common software block design
method is called component design. This is where we define small functional
software blocks that have certain tasks. We define the interface mechanism and the specs that each modules
needs to adhere to. By doing this, you can build modulized
software that is reusable across different systems, architectures and platforms. This will allow software developers to
easily migrate certain software solutions without significant system changes. It is very important you understand
that with this design paradigm, good interface definitions are a key for
successful implementation. Example components can be seen in the
layers where a wireless control embedded system is built. There's is a hardware firmware layer
that controls peripheral hardware. There's an extracted interface to this
layer that is hardware independent. Those are interfaces with some high
level communication libraries, above that is a control library
that utilizes hardware interfaces. Historically a software engineer
was dependent on the development of hardware systems. Hardware designers provide
the specifications that software engineers would use to interface
with the hardware layer. Without hardware,
no on-target testing could occur. On-target testing is just a term
that refers to installing your code on to your particular embedded
system instead of another. So new chip sets or printed circuit boards
had to be built with the desired hardware and connections so the software engineer
knew what they needed to configure. Thankfully, new hardware
development techniques and system emulation provide quality
resources for low level development. Take for example the introduction
of development kits and the SDKs that allow us to
rapidly prototype software. It's not only enabled engineers to begin
writing low level code or firmware but also provided them with the physical
resources to test code on. We discuss developing gets a more
detail later in the module. There are five main development tools that
allows software engineers to get started on development and
testing of their applications. These are first simulators,
software that imitates or intended to hardware's behavior
without the actual hardware. Emulators, the hardboard platform
that imitates the operation of your intended system. Compilers, it's the software that allows
developers to pre-executable code for their intended architecture. Installers, a software-hardware
combination that allows compiled executable programs
to be installed onto a platform. And debuggers,
a hardware-software solution that allows programmers to test and
validate their executable programs. These tools are important because
developing hardware takes time and it's expensive. The software engineer's role oftentimes
will not only include the design of the software product, but also software
validation of the hardware platform. A complete hardware design and
documentation usually finishes first, with software following. These five tools make the job of
the embedded software engineer easier. How? Simulators and emulators will allow validation of design
to occur before the arrival of hardware. Compilers, Installers, and debuggers will provide a quick development
of features for your embedded target. And an easy way to fix off our bugs. Having the ability to do this in software
gives the team more flexibility and likely a cheaper product development cost. Prototyping software fast is important,
but not at the cost of quality. This leads to the principles
of high quality software. These principles are beliefs that ever
software engineer should keep in mind as they write code,
to achieve maximum amount of quality. This less includes but is limited to
writing code that is maintainable, testable, portable, robust,
efficient and consistent. By keeping this tenants
in mind was software, you can ultimately write better code,
speed up development by using all code and produced system bug free software. A common misconception is
that the advanced platform a general programmer might use. That the advanced hardware will make
up for poorly written software. This is not true,
especially from an embedded perspective. because even the best hardware
cannot make up for buggy, slow, or inefficient embedded code. By putting time into architecting your
software, writing code effectively. Making it modular, you can extend the
lifetime and re-usability of this pieces, of your various projects and platforms. This obviously speeds up embedded
systems prototyping time lines and the rate with which you can hit
the market with your product. There are many embedded software languages
use in the industry such as C, C++, Java and Ada. But C-Programming is the most widely used
language for embedded software design. C-Programming has benefits for
both low level hardware interactions and high level software language features. This provides portability across
different embedded platforms. Software engineers choose to use this
over a Symbio language for many reasons. C is high level enough that you
do not need to know every detail about the very specific
assembly level architectures. Assemblies often still
used together with C for a small number of embedded features,
but very few regular occurrences. Regardless, all higher level
link images need to be converted into the architecture specific language
before installation can occur. Typical embedded engineers actually
write a form of C called Embedded C. Embedded C differs from C because it
puts a focus on the following features. Efficient memory management,
timing centric operations, direct hardware/IO control, code size
constraints, and optimized execution. In general, you can think of Embedded C as optimum
features in minimum space and time. Putting some thought and design time
in your embedded software project is important before you begin coding. You have many tools at your disposal
to help you in your development. Do not be afraid to use them. Your goal should be to design high quality
software that could help prevent bugs and even provide reusability of code. These tools and concepts will help us
write the most efficient embedded C programs for our projects.