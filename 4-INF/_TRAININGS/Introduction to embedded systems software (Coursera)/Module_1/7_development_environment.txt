In this video, we will discuss the
development environments for creating and testing our embedded software projects. Development environments are key for software engineers as they are the means
with which a software project is created. The embedded system target is important,
but all of the software is designed
outside of that system. You need some method of
generating an executable file and installing it onto the device. And finally, certain external support
is needed to texture working design, these responsibilities and more
are defined by your working environment. The primary goal of the development
environment would be to allow engineers to write, compile,
install and debug a program. There will be many options for
the tools you can write code in. But a project will often have very few
options for the compiler, installer and debugger. And unfortunate consequence to this will
be that some of these programs may not be supported on every desktop OS. You as a software designer will hope that
you have an interface that allows you to utilize all possible
features of this tools. In order to show all of the features
that the development environment offers. We'll be using two different
desktop environments. A command line in a Linux environment and a vendor's
Integrated Development Environment. First, we will discuss using the software
tools using the command line interface or CLI on a Linux OS. Building software project using command
line is the de facto standard amongst software engineers. The command line interface gives
you a powerful level of control of applications at the expense
of user interface. You'll provide complex commands
to the computer via text input. The command line is typically
a power user interface. Command lines are not regularly used
because they are not as intuitive, but they exist on many computers. We'll use a Linus, a Unix based
operating system OS to practise applying these software tools because
of its flexibility and popularity among software
engineers at the environment. The course we're using
Ubuntu Linux distribution. However, there are many distributions
of Linux, you can choose from, such as RedHat, SUSE, Gentoo and Arch. You have the option of either
using Linux directly or using a virtual machine with
a Linux distribution installed. In addition, we will use this host
Linux environment to run tests and simulate certain pieces of software. If we design appropriately, we can test
architecture independent code on our host machine to validate functionality. If anytime in this course you see
text written after a dollar sign, that will indicate that the following text
should be typed into the command line. In Linux, we'll use different programs to
perform these four software operations. Starting with your editor, you are free to use whatever
editor to develop your code in. The simplest editor you can use would be
a text editor such as Notepad++, Vim or Sublime Text. Some file editors have some options for
integrating compiler debugger plugins that would make them look more like
an IDE that is not vendor specific. For compilation, you will use GNU's toolset to generate
our software executable files. Installation and debugging will be
an architecture dependent thing. However, installation could be as
simple as copying our executable or invoking an installer program. Debugging will depend on the target. Host debugging can utilize a command
line tool GDB, the GNU project debugger. On target debugging can be done
through a network debugger or connected hardware debugger. These two require some type of physical
control of our microcontroller. The second environment you want to
interact with is a vendor provided integrated development enviroment. IDEs encapsulate all of the functionality
that we get from the command line. But they provide a much more
interactive use interface. The IDE will hide all of
the details of how the compiler, installer and debugger application
are being invoked from the developer. This interface is usually less ideal for
software engineers because the trade off for a good UI might restrict
a developer's capabilities. However, many features of the IDE provide
more user friendly methods for developing and debugging an application including
more informative memory graphics. With the IDE we will perform
all four steps of our software design tool set in this one environment. In this video, we learned about two
specific development environments. These environments will be key, not only
to the development of our projects but to the validation. Learning tools has some ramp up time
period, but the experience we will build with these environments will be
adaptable to almost all software projects. These skills will be key to your success
as an imbedded software engineer. Here's a demo of the Linux
virtual machine. Looking into Linux Virtual Machine,
we can easily open up one or more command line terminals. Again this interface is just
a capture based alternative the clicking through icons and
configurations via UI. We will not go into many of the Linux
command inline utilities in this video. Since we gained the experience of these
that they work on their assessments through out the course. However we start by looking
at our current directory. We use the present working directory,
pwd command, to do this. Next, I will list the current files
that are in this particular folder using the list command, ls. We will then change the directory
using the cd command to a folder where an example
software project exists. Running pwd shows that we have
successfully moved into a new directory. Here you can see a file name
main.c that I'm going to edit, compile and then I'm going to run it. I will edit using vim and
by specifying the file I wish to edit, I will then make some changes to
the file via some vim commands. You can look up these outside
of class if you're interested. I'm going to change the hello
world text to something different. I will save the file and exit. Now I'm going to compile this file
with a very simple GNU GCC command. No output here means,
we complied successfully. And finally, I'll run the command
using the ./ notation meaning run this executable in this current directory. The dot means the current directory and slash separates the folder from other
folders or files, any file path. The output is printed to
the screen via standard out. We will actually use
a different compiler for the on target executable
than the one shown here. Here, we're going to do
the Kinetis Design Studio demo. This demo is to show you
a little more about IDE. Here, we have pulled open
Kinetis Design Studio, an ID developed by an XP semiconductor. This IDE is an eclipsed base IDE and the features we will discuss are pretty
consistent across other vendor IDEs. There are two views of interest
in a typical embedded system IDE. With software development view and
the debug view. The software development view
provides many shortcuts and integrated compiler support to help
design and build a target application. On the left side of the IDE, we have a
project explorer that holds references to multiple software projects at a time and
all the contained files within them. You can easily add and remove files here
or change the properties of a project. Inside the properties are all the fine
controls of development environment. Here, we can modify compilers,
installers, and debugger configurations. Changing configuration parameters
is very click from the command line of much more manual from the IDE. By clicking on C/C++ Build > Settings
> Tool Settings > Target Processor, you can see that this project was
designed specifically for arm cortex-m0+. Clicking back to the Tool Settings > Cross
ARM C Compiler, you can see that this environment is indeed running command
line commands behind the scene. However, they make use
command line variables to make the interface more dynamic. Moving out of the properties and into the editing window,
you can modify code as you please. You get tasks to help switch
between different files and even highlighting certain code or hovering over it provide interesting
quick insight into its definition. Right clicking these, you can find
that declaration of a piece of code or even the references to it. With the compiler integrated, I can build from this window by selecting
from the drop down menu Project Build. The debug view will provide
us some special controls and test to debugging install application. By invoking the debugger, we won't start
our program into the connected target. We will use this debug feature
more detail later in the course.