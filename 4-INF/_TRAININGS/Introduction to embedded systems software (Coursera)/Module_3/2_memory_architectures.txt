In this module, we will continue to
discuss memories by diving deeper into different technologies,
architectures, and features. An embedded system is defined
to be a computerized system with a specific function. This could be implemented purely digitally
or with a processor and some software. This ladder choice suggests that one
of the main characteristics should be the ability to program your system. A process of writing a program and then compiling an executable is
only a part of this design process. We need to install this executable, and it needs to be installed
into physical memory. And not just any memory, memory that
can retain the software programs so they can be run over and over again. This program contains
both operations in upper ends that need to be processed in
order to meet a desired functionality. The ability to retain a program,
execute it and operate on data are just three of the characteristics of
memory that we need to discuss further. Memories come in many different forms and
characteristics. Knowing the features of memories can
help us optimize our software and understand how it interacts with hardware. We usually model memory as
a long two dimensional array each row index representing
a different memory address in each column index representing
different bits or bytes. Data is read and written to memory based
on some types of protocol or handshaking. Usually this handshaking is managed
by some type of memory controller that interfaces between ROM memory and
the CPU. You need to provide the controller a
minimum two to three pieces of information depending on the type of operation you
are intend to perform on the memory. You start with an address to indicate
the memory location of interest. Next, read or write signal allows you to determine what
you want to do with that memory location. And finally, data can also be provided if
you planed to write information to that specific address. These are not the only types of
signals you might send to a particular type of memory. You could send many other operations,
such as erase, strobe read and write, or even configure. Let's investigate some of the most
important characteristics about memory. These include memory capacity,
volatility, access, power consumption, latency,
durability, and transaction size. Each of these characteristics can
directly affect the cost of memory, and we will need a range of these to create
our embedded system effectively. You are already introduced to
a hierarchical layout of memory that shows a computerized system that consists
of many different types of memory. We represent this with a pyramid. And that shows the relationship of speed
being somewhat inversely proportional to the capacity and cost. Limiting cost is a focus of chip
manufacturers as well as our embedded system designers. Therefore, we need to know a little bit
more about each of these types of features of memory and how they
are implemented in physical devices. Capacity refers to the amount
of storage a memory can hold. Capacity would seem like it would be
the most important aspect of storage. However, more memory does not mean
improved performance or quality. Bulk memory storage on an IC, or an integrated circuit, will increase the
size of your chip, the power requirements, and potentially the complexity
of your circuit. Increasing the size and the power
requirements can have a significant impact on the mechanical design of your system
and again this will affect cost. Generally, you would like to
limit the physical size and cost of your embedded
system as much as possible. For basic microcontroller applications
larger capacity is not really needed. However, for more complex embedded OS
applications larger capacity of the store OS based resources would be necessary. The next characteristic is volatility. Volatility refers to the ability of
memory to store data without power. There are two types. Volatile Memory which
requires power to store data. This usually applies to register
memory in program and data memory. Some physical examples of these are SRAM,
DRAM and SDRAM. And non-volatile memory, which does
not need power to retain information. Non-volatile memory is typically
where you want your program to be. A space that can be turned on and off,
without having to reinstall your program. Non-volatile memory includes physical
types like PROM, EEPROM, flash, disk or tape. You might ask,
why would you even want volatile memory, if non-volatile memory is available? Unfortunately some of the characteristics
of non-volatile memory also exhibit endurance issues. Meaning they cannot reprogram
an infinite number of times. You can see this with our evolution
of non-volatile ROM type of memories. Early visions of ROM or read only
memory were only programmed once by the manufacturer and
it remained unchanged. Eventually, a programmable ROM or PROM was introduced at this provided
a difficult yet functional method for customers to do a one time program,
but this could not be a race. Then came variance which allows for
erasable PROM, EPROM. Some versions of this technology
had to use ultra violet light to use memory to erase. Eventually technology was developed
to allow for both the erasing and the reprogramming of memory, the EPROM. This would eventually into flash,
however flash would have some limitations. The process of riding and
erasing flash would eventually fail. As flash is usually only meant to handle
some large limit of right array cycles. This flash endurance of right
array limit is quite large, though somewhere between tens of thousands
to hundreds of thousands of cycles. Newer technologies have begun to increase
this limit higher and higher, but endurance is still an issue. In fact, cloud storage has begun towards
large flash arrays because of it's improved endurance and the speed that
you get with respect to disk and tape. However, the different
versions of this ROM type of memory still holds a place today. ROM is still used for
vendor-provided firmware or configuration that does
not need to overwritten. Next, let us look at the physical
access to different memories. The first being the ability
to randomly read and write memory freely to any location. This is called the Random Access Memory or
RAM. Random Access is very convenient for info that needs to change
regularly like a program data. However reducing the access to a certain
types of memory can be desireable if you want to protect it
from being overwritten. For this case, you may want the memory to
be Read-Only or Read-Only Memory, ROM. Typically ROM requires some more
permissions, it more involve process, and maybe even require certain credentials
in order to read or write. Reducing access to writing can
provide security for your software or even add safety for
potential errors with overwriting. Reading and writing can be simple on
random access memory, allowing for access down to the byte. However, some flash based memory does
not allow for random access of data. Instead, memory's organized in blocks
which are made up of many pages. Typically, reads and
writes can happen at a page level but erases happen any block level. Because of this, it is necessary that we
builds some technology around flash to cache information into read or
stores or other data. To reduce frequently reading and writing information which would actually
help us reduce memory latencies. Memory latency is a very important
characteristic to consider with embedded systems. With the limited number of
computer resources we have, we need to make sure that the CPU is
doing useful work as much as possible. Since the CPU needs to read and write
data from memory, this can take time and maybe even delay our
applications completion. Luckily, I see designers figure out how
to limit memory transaction latencies by introducing concepts like
pipelining in caches. Most microcontrollers you will see already
have been designed to some level of pipelining built in and
we will discuss this later in the course. A cache is a piece memory to help read and write data out to slower memory,
lower down in our memory hierarchy. However, cache system do not usually exist
on our cheapest, small microcontrollers. More advanced ARM processors like ARMv8A
contains multi-level cache system. There are many different characteristics
of memory that we need to take into account on an embedded system. Modern embedded systems utilize a variety
of memory technologies in order to function most efficiently
with the lowest cost.