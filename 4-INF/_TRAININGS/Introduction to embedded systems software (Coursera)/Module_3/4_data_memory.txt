In this video we'll take a detailed
dive into the program's data and the sub segments that make this up. We generally refer to this data
memory as the data segment. You spent a great deal of time learning
about the different physical memories of a micro controller. Including flash, RAM and
Register memories. Each with a different characteristics. These characteristics included things
like volatility, speed, access, as well as many others. A microcontroller utilizes these memories
in many different ways when a C program is built and installed on an embedded system. A compiled program references two basic
blocks of memory, the program code and the program data. These two types are also known
as the code and data segments. Both of these segments map compiled
segments to a physical address space provided via the linker file. Data memory can be generically described
as the operands that are program executable operates on. Data memory can have
many different forms for data address information, configuration
information, or just raw application data. At a minimum, you should think of the
variables that you create in your program as your data memory. This includes derived data types
such as pointers, structures, and arrays, in addition to single variables. The contents of your data
memory is regularly changing throughout your program's execution. This is done by loading your data from
your data memory into CPU registers, operating on it there, and
then storing the results back into memory. However, in order to properly describe
data memory in the data segment, we will not refer to data as variables but
as allocated data. Meaning not all data we create needs
to be in the form of a variable. Data can be allocated both
at compile time and runtime. In addition data can have
different characteristics regardless of your data and the different
methods of managing your data we will generally represent it all as
being a part of the data segment. The data segment is a method
of organising data memory and compile time in order to map
address in the physical. The data segment is broken
into four main sub segments. These are the stack the heap the data and
the BSS regions. Each segment size depends on
how you wrote your program. The Stack stores temporary
data in most local variables. The Heap stores dynamic
information at runtime. The Data region stores non-zero
initialized global and static data. And the BSS stores uninitialized and
zero initialized global and static data. Let us open up our linker file example. Since our code memory contains
our operations that we perform, those operations needs to
know exact locations on where the data they are operating on exist. The linker file provides segment and
sub-segment mapping to physical memories. Careful management of the code and data at
compile time substitute the loading and storing of data into
the CPU using addresses and address offsets to unique locations and
memory. Here you can see the same sub-segments
of the data segment we have spoken about previously. They met to a physical data
region of RAM type memory and have a length of 64 kbytes. Without carefully managing
these data locations and memory you could easily corrupt your
data by mis-addressing a variable or writing outside the bounds
of the segment space the linker file will specify in
what order they should be placed. Therefore, each sub-segment also has
boundaries given either by a link or flag, or
by the size of the memory you allocated. It is highly likely that not all the
memory will be allocated at compile time. This will just leave some leftover
memory unused for your program. If you were to create a physical
graph of this memory regions and you can see how they line up
contiguously and the address phase. Starting at the origin of addresses and
going for the link of the memory. In this example, you can see that
the stack was place at a high address. Meaning instead of placing this right
after the hit, place it starting at the end of memory region and have
a descend back towards the other segments. This type of stack is specified as a full
descending stack meaning it starts at a higher address and grows towards lower
addresses as more data gets added into it. There are many different characteristics
that variables in data can have in your program. Data can have different sizes, allocation
times, life time, scope and locations. This method of allocation and management
of data are handled in number of different ways, specific CQ words like just
Type Qualifiers, Modifiers and Storage Classes can help specify how your
variable means to be manage, compiler tributes can also give us extra option
to manipulate how data is allocated. There are also some runtime routines that
can help us allocate data at runtime. The most obvious characteristics
of data is the size, and it's specified by either a C data type or
they run time parameter. However, data sizes are architecture and
compiler dependent. The C standards specifies minimum
size that some types must be. But a compiler in an architecture
can manipulate types differently. We will discuss this in more detail later. Lifetime and scope of data are somewhat
related, there are three forms of lifetime these include data that exist for
the lifetime of a function or a block, data that exist for
the lifetime of a program. And data that exist for longer than a
function but less than a program duration those local variables only exist for
the length of the function or block. This allocated in runtime
when the function is called there destroyed when the function returns,
this variables have locals scope which means there only accessable
during the function of block. The memory they occupy is reused by
other functions as a program executes. The only exception to this are local
variables created with the static type storage class. Global variables are variables that
get allocated at compile time. They have a lifetime of the entire
program and are never destroyed. This one time allocation
cause global variables to occupy memory that can never
be reused during a program. In addition,
global variables have a global scope meaning they're accessible
by other parts of a program. Other functions are interrupting can
openly access a global variable. In addition to global variables memory can
be allocated directly in the linker file in referencing your program. And it will be allocated for
the lifetime of the program. We will leave this as an advanced
programming topic for later in the course. Lifetime and scope vary slightly in
the sense that most local variables have a lifetime of a function or a block. And all global variables have
a lifetime of the program. There are, however, a third kind of
data allocation that can live for longer than a function,
but less than a program. This is referred to as
Dynamically Allocated Data. This requires special routines to
allocate and free data at runtime. There are many issues with
managing dynamic memory. However Dynamic Allocation allows
you to re-use memory over and over again rather than
statically allocating it. It also provides you with the ability to
access data outside of a local scope. We will discuss dynamic memory
into some more details later. One major issue with data memory
is that data stored in RAM is lost when power is removed
from the microcontroller. Therefore, all the state and all the processing and execution is lost
because RAM is a volatile memory type. Data can also be stored in
non-volatile memory such as flash, but it is a slower and more difficult process to write data to
flash during the execution of a program. You're likely to see an extra piece of
non volatile memory connected to your micro controller for data that needs
to be retained between power cycles. Almost all programs have some type of
non volatile data they need to store. You have likely written programs with
variables that have initial conditions. These are non volatile pieces of data. They need to be initialized at
the beginning of execution of a program or a function. A data segment contains many different sub
segments that are used for different kinds of data, allocation of data can be
at compile time or at run time. Certain parts of the data segment
can be reused and others exist for the lifetime of a program. Scope and access to variables can also
dictate the section of the data segment where certain pieces of data exist. Next, we'll show how to allocate
data in these different segments with your C programs.